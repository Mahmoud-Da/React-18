*** 1-_What_Well_Build ***
we will build a tiny versoin of Rawg Site
https://rawg.io/

when we build project or feature(method)
first: Make it Work
second: Refactor the code 
third: Improve the code


*** 3-_Setting_Up_the_Project
we create React Project
npm create vite@4.1.0

we call the project: game-hub
we use TS then inside this project file we install all the dependencies
then run our project with npm run dev


- we connect our project to gitHub
1- initialize our project to  git repository
git init 
2- to add all the changes in our dirctory to staging 
git add .
to add our 
3- we commit our changes 
git commit -m "Initial commit"

4- we go to GitHub to create that repository (check the instruction of gitHub)

here we commit our code "create game-hub App"
*** 4-_Installing_Chakra_UI ***
there is too many libraries for styling UI (bootstrap, tailwind, chakraUI)
for this project we will use ChakraUI

https://v2.chakra-ui.com/

PS: 
1- to install it we press go started and chose the installion for Vite
2- we will not do the optional things right now ex: Customizing theme (Optional)
-------------------code----------------------
when we add 
import { ChakraProvider } from "@chakra-ui/react";

it`s better to orginze our import statment code 
ex: 
- import the React libraries first 
- import the third libraries
- import the local files 
-------------------code----------------------

now after read the installion
we check if ChakraUI is installed by adding a button 

after remove everything in the App.tsx
we add button (method: ChakraUI site)

we see u ugly blue border around the button when we hover
coz we havn`t remove the the code from the index.css (so we remove all the style the code inside it to fix that)

until this point we check the git tree of of our chnages (always make sure to do that before commit to avoid commit unnecessary code )
and we commnt our code  "install ChakraUI" 

to check our commit until this point we type
git log --oneline 

PS:to check the first three commit only 
git log --oneline -n 3 


5-_Creating_a_Responsive_Layout
we want to add navbar to the top and side panal to the left and the main area in the middle

to do that we are going to use Grid component:
first we remove the everything from the App component coz we don`t need it any more

we use Grid component from the ChakraUI

<Grid templateAreas={``}></Grid>

PS: we used `` coz inside it we will add double string quotation　
ex: `"" ""`

now we want Nav on the top and side menu on the the left and main area
like this 
-------------------code----------------------
<Grid
        templateAreas={`"nav nav" 
                        "aside main"`}
      ></Grid>
-------------------code----------------------

now inside the Grid component we create GridItem and give an area from our four areas ()
<GridItem area={"nav"} bg={"coral"}>
          Nav
</GridItem>

and give it a bg (backgroud) color to see it

we duplicate this component  with 3 times Nav  Aside with our four areas

-------------------code----------------------
 <Grid templateAreas={`"nav nav" "aside main"`}>
  <GridItem area={"nav"} bg={"coral"}>
    Nav
  </GridItem>
  <GridItem area={"aside"} bg={"gold"}>
    Aside
  </GridItem>
  <GridItem area={"main"} bg={"dodgerblue"}>
    Main
  </GridItem>
</Grid>
-------------------code----------------------

now on the mobile devices we want to hide the aside panal to do that 
in the 
-------------------code----------------------
templateAreas={`"nav nav" "aside main"`}
-------------------code----------------------

we change string of templateAreas to object and inside it we can define the template area for each screen size
PS: for better understaing visit Chakra UI then access to "Styled System" then click on "Responsive Styles" we can check the break points
https://v2.chakra-ui.com/docs/styled-system/responsive-styles

in our Project we will design our UI for two sizes normal and mobile
-------------------code----------------------
templateAreas={{
          base: `"nav" "main"`,
          lg: `"nav nav" "aside main"`,
        }}
-------------------code----------------------

we check our layout on the Devtool 
we see the aside template still there coz we still render it on the screen 

to make sure that Aside GridItem only render on the base tamplate
we should wrap it with Show component and give a property of "above"
-------------------code----------------------
<Show above="lg">
  <GridItem area={"aside"} bg={"gold"}>
    Aside
  </GridItem>
</Show>
-------------------code----------------------

here we commit our code 
"Build a responsive layout"


*** 6-_Building_the_Navigation_Bar ***
now we will wikr only on the basic layout for the navigation bar 
this how we build a project start with simple functionality then we move to the next step 

- we create components folder inside the src folder 
inside it we create NavBar.tsx and we use rafce
we remove unused import React statment

- now we want to layout our items in this component horizontally 
to do that we can use Component in ChakraUI called HStack (whcih means horizontal stack)

- inside the HStach component we use Image component by typing Image we have two Image components
we use the Image instance of ChakraUI
*********************
PS: to see that in options we type <Image munally 
we have two instances one for normal interface and one is the Image of ChakaraUI
*********************

- we download the logo image from from GameHub Resources.zip and move the logo.webp to the assets
ps: webp image are high optimize images for web 

- in Image ChakaraUI Component we can`t use src={} with path intead we import the image as 
JS module and use the imported object inside the src 
-------------------code---------------------- 
import logo from "../assets/logo.webp";
<Image src={logo}></Image>
-------------------code----------------------

- now we add our NavBar Component in the App.tsx 
we change the NavBar word with NavBar Component

- we check our code and we see that our logo is two big so we need to resize it using boxSize
-------------------code----------------------
<Image src={logo} boxSize="60px"></Image>
-------------------code----------------------

- we are using horizontal stack now if we add text in our navbar it should appear after our image
to check that we add a Text component (instance of ChakaraUI)
-------------------code----------------------
<HStack>
  <Image src={logo} boxSize="60px"></Image>
  <Text>NavBar</Text>
</HStack>
-------------------code----------------------

- now normally after building our layout component we remove the backgroud color coz we don`t need to check the layout
anymore 
so in the App.tsx we remove 
-------------------code----------------------
 bg={"coral"}
-------------------code----------------------

now after review our code now we add commit to our repository
"Build a NavBar"


*** 7-_Implementing_the_Dark_Mode ***
in the documentation of the ChakaraUI we search for "color mode" in this page we can read how color 
mode works in ChakaraUI to Implement the dark mode we have to do some steps we 
don`t have to memorize it we can see it in the documentation.

- in the src folder we create a file we called theme.ts
here we are going to customize our default theme whcih come with ChakaraUI
we copy all the code from the  and change the initialColorMode to dark 
https://v2.chakra-ui.com/docs/styled-system/color-mode

- we go to main.ts and import the theme.ts
first we import theme
then we have to use it in two places 
-------------------code----------------------
import theme from "../src/them";

ChakraProvider theme={theme}>   /=> first place
<ColorModeScript /=> second place
  initialColorMode={theme.config.initialColorMode}
></ColorModeScript>
<App />
-------------------code----------------------

- now if we refresh our page the page is still light coz ChakaraUI stores the selecetd mode 
in the local storge so it can remmeber it in the future sessions

we can check that with dev tool and went to Application then Local Storage
and delete the "light" key 

- now if we refreshed the page we got black background 
now we checked the Local Storage we can see it "dark" 

here we commit our code 





*** 8-_Building_the_Color_Mode_Switch ***

now we will create switch button to change the color mode between light and dark modes

now in the component folder we create ColorModeSwitch.tsx 
inside it we create horizontal stack component coz we need the label to be next to it
ex:
○ Change Mode

-------------------code----------------------
<HStack>
  <Switch></Switch>
  <Text>Dark Mode</Text>
</HStack>
-------------------code----------------------

to work with color mode we have to use custom Hook that defined in ChakaraUI 

first we search on google 
useColorMode 
and in documentation

https://v2.chakra-ui.com/docs/styled-system/color-mode#changing-color-mode

so according to the documentation:
- first we import useColorMode hook from the ChakaraUI
- then we called useColorMode  and Destructuring (分割代入) toggleColorMode and colorMode
-------------------code----------------------
Destructuring object 分割代入は、中カッコ{}に取り出したいプロパティを指定することで、
プロパティ名と同じ名前の変数が作れます。次の分割代入のサンプルコードは、
上のプロパティアクセサーを使ったコードと同等の処理になります。

const item = { price: 100 };
const { price } = item;
// 上は const price = item.price; と同等の処理

複数のプロパティを取り出す

分割代入は、複数のプロパティを一度に取り出すこともできます。その場合、取り出したいプロパティを中カッコに列挙します。

const obj = { a: 1, b: 2 };
const { a, b } = obj;

引用+詳細：
https://typescriptbook.jp/reference/values-types-variables/object/destructuring-assignment-from-objects
-------------------code----------------------

- then we modify the switch component 
-------------------code----------------------
<Switch
  isChecked={colorMode == "dark"}
  onChange={toggleColorMode}
></Switch>
-------------------code----------------------


- now we add the ColorModeSwitch component to our Nav component
and replace the 
-------------------code----------------------
<Text>NavBar</Text>
-------------------code----------------------
with 
-------------------code----------------------
<ColorModeSwitch />
-------------------code----------------------
finally we remove unused components

- and we test our code until this point 

now we don`t need the background color of Aside and Main Grid so we remove their bg  
-------------------code----------------------
bg={"gold"}
bg={"dodgerblue"}
-------------------code----------------------

- to make our switch button look more beautiful we add colorScheme to Switch Component
-------------------code----------------------
<Switch
  colorScheme="green"
  isChecked={colorMode == "dark"}
  onChange={toggleColorMode}
></Switch>
-------------------code----------------------

- finally we want to push the switch button the right side to do that 
we go to our NavBar component this work exacly like flex container 
-------------------code----------------------
<HStack justifyContent={"space-between"}>
-------------------code----------------------

- now our button is close to the right side but it so close to the edge of the screen
so we need to apply some padding to the HStach component
-------------------code----------------------
<HStack justifyContent={"space-between"} padding="10px">
-------------------code----------------------

now we review our code and commit it to our repository
"Build the color mode switch"

*** 9-_Fetching_the_Games ***
now we will fetch the game from rawg.io 

- first sign up
- get API KEY 

- install axios for sending api requests

- now we need to create axios instance with custom configration, in that configration we will 
include that API-KEY whcih we copied 

- inside the src we create services folder 
inside we create api-client.ts 

- inside the api-client first we import axios on the top then we call the create method to 
create axios instance with custom configration inside we create params object and set the key to the API-Key from 
the rawg.io
-------------------code----------------------
import axios from "axios";

axios.create({
  params: {
    key: "API-KEY",
  },
});
-------------------code----------------------

- with this configration our API-Key will be included in every HTTP request we send

- to we set the baseURL:
first we go to the https://api.rawg.io/docs/
we have multi endpoints 
we go to the games -> get a list of games 
if we scrol down we can see the object that come back from the server (respone)
-------------------code----------------------
{
"count": 0,
"next": "http://example.com",
"previous": "http://example.com",
"results": [
{}
]
}
-------------------code----------------------
if we click on GET/games we can see the full URL 
https://api.rawg.io/api/games
to use as baseURL we need remove the games so we have 
https://api.rawg.io/api

- now we need to export as default object
-------------------code----------------------
import axios from "axios";

export default axios.create({
  baseURL: "https://api.rawg.io/api/games",
  params: {
    key: "c7b18323a47d40c394ea5b019646b1f5",
  },
});
-------------------code----------------------

- now we create a new component called GameGrid
- in this component we state hook to store our games object (data from the server)
-------------------code----------------------
const [games, setGames] = useState();
-------------------code----------------------

- then we need to store error of we had errors during fetching the game 
-------------------code----------------------
const [error, setError] = useState();
-------------------code----------------------

- then we should use Effect hool to send fetch request to the server/backend
and inside we need to use apiClient so we import it from api-client.ts

-------------------code----------------------
import apiClient from "../services/api-client";
-------------------code----------------------

- now inside the useEffect we sent get request to ("/games") and if the responese goes well 

-------------------code----------------------
useEffect(() => {
    apiClient.get("/games").then((res) => setGames());
  });
-------------------code----------------------

- we need to define the interface to grap the Response objects (count, next, previous, results)
in this project we will not care a bout the (next, previous) at this point only we need number and results

-------------------code----------------------
interface FetchGamesResponse {
  count: number;
  results;
}
-------------------code----------------------

- now lets see what data we have in the response
in https://api.rawg.io/docs/#operation/games_list if press on results 
we can see the data like [id, slug, name, and so...]
for now we only want to grap the [id, name ] later we will add another properties when we need them 
so we are not write code we will not use right now 
-------------------code----------------------
interface Game {
  id: number;
  name: string;
}
-------------------code----------------------
- withthat we can see we set the results to type Game Array

-------------------code----------------------
interface FetchGamesResponse {
  count: number;
  results: Game[];
}
-------------------code----------------------

- now when we send get request to server we use <> to provide  generic type argument that is FetchGamesResponse
with we can know the shape of res object {AxiosResponse<FetchGamesResponse,}, so if type setGames(res.) we can see 
the property of the response that comes with axios here we need to access data property so we read the body
of the responese setGames(res.data.) and here we can see the property that comes with the API so we have [count and results]
-------------------code----------------------
useEffect(() => {
    apiClient
      .get<FetchGamesResponse>("/games")
      .then((res) => setGames(res.data.results));
  });
-------------------code----------------------

- now we compilation error coz we set the useState of games to empty Array
so we have to tell the TS compiler that it`s game Array

-------------------code----------------------
const [games, setGames] = useState<Game[]>([]);
-------------------code----------------------

- now what if we got an error, so by using catch method we setError to err.message 
-------------------code----------------------
useEffect(() => {
    apiClient
      .get<FetchGamesResponse>("/games")
      .then((res) => setGames(res.data.results))
      .catch((err) => setError(err.message));
  });
-------------------code----------------------

- now to check id our implomantaion is currect we render the games names 

-------------------code----------------------
<ul>
  {games.map((game) => (
    <li key={game.id}>{game.name}</li>
  ))}
</ul>
-------------------code----------------------

- in the App.tsx we instead we change Main with GameGrid


- now what if we have an error 
we need to render it on the top of our markup
-------------------code----------------------
{error && <Text>{error}</Text>}
-------------------code----------------------

- we simulate error our test our error rendering error 
-------------------code----------------------
.get<FetchGamesResponse>("/xgames") 
-------------------code----------------------

- until this point now we commit our code 
"Fetching Games from the server"



*** 10-_Creating_a_Custom_Hook_for_Fetching_Games ***
now in our GameGrid Component we are working with the backend ex:
we have get method an later we have to use controler abort
so our component knows about backend and frondend as the same time
we need to make our component only responsible for our frontend (return markup and handle events) 

here we have two options:
1- move the logic that has HTTP request (get) to servise (ex: service/games-service.ts)
like we do in the previous section.

2- the next option is to move all the entire logic (all useStates and useEffect) to custom hook 

so we can create custom hook not for only specific handling but also to moduler our code and make it more useble
so we will create custom Hook for fetching the games 

- inside the src folder we create hooks folder 

- inside the hooks folder we create useGames.ts

first we create variables called useGames and export it
-------------------code----------------------
const useGames = () => {
  
};

export default useGames;
-------------------code----------------------

-  now we move all the hooks from the GameGrid.tsx to our custom hook 
-------------------code----------------------
const useGames = () => {
  const [games, setGames] = useState<Game[]>([]);
  const [error, setError] = useState("");

  useEffect(() => {
    apiClient
      .get<FetchGamesResponse>("/games")
      .then((res) => setGames(res.data.results))
      .catch((err) => setError(err.message));
  }, []);
};

export default useGames;
-------------------code----------------------

- now we will resolve the errors 
- first we move the Game and FetchGamesResponse interface to our custom hook and export them 
- then we move the useState/useEffect import statment and apiClient to the custom hook 
- finally we have to return the error and games object to use them in our component

-------------------code----------------------
import { useEffect, useState } from "react";
import apiClient from "../services/api-client";

export interface Game {
  id: number;
  name: string;
}
export interface FetchGamesResponse {
  count: number;
  results: Game[];
}

const useGames = () => {
  const [games, setGames] = useState<Game[]>([]);
  const [error, setError] = useState("");

  useEffect(() => {
    apiClient
      .get<FetchGamesResponse>("/games")
      .then((res) => setGames(res.data.results))
      .catch((err) => setError(err.message));
  }, []);

  return { games, error };
};

export default useGames;
-------------------code----------------------

- now we go back to our component and clean some code 
- first we remove unnecessary import statment
- we import useGames hook and retrun games, and error objects

-------------------code----------------------
const { games, error } = useGames();
-------------------code----------------------

- now our component is cleaner and don`t know anything a bout HTTP request and only returning markup

- next step to handle out cancelation 
-------------------code----------------------
1- const contoller = new AbortController();
2- ("/games", { signal: contoller.signal })
3- return () => contoller.abort();
-------------------code----------------------

- now in our markup we see canceled as the top 
*********************
canceled

Grand Theft Auto V
The Witcher 3: Wild Hunt
Portal 2
Counter-Strik
*********************

to fix it 
-------------------code----------------------
.catch((err) => {
        if (err instanceof CanceledError) return;
        setError(err.message);
      })
-------------------code----------------------

- now if we refreshed our Browser we can see in the Network tab that we have two requests to the games api
 the first one canceled coz our react unmount our component at the first time coz the strict mode

- now we commit our code untile this point
"Create a custom hook to fetch the games"


*** 11-_Building_Game_Cards ***

next step is replace the ● the points with Game cards
- we create GameCard.tsx 

- next we should pass a game object as props for this component

interface
-------------------code----------------------
interface Props {
  game: Game;
}
-------------------code----------------------

PS: but we need to import Game interface form our custom hook
-------------------code---------------------- 
import { Game } from "../hooks/useGames";
-------------------code----------------------

PS: importing interface from custom hook is kind ugly but we will fix it later

- after creating Props we are going to pass Props as argument
and we will return Card Component (import from Chakra UI ) and inside it Image component from ChakaraUI either.

-------------------code----------------------
import { Game } from "../hooks/useGames";
import { Card, Image } from "@chakra-ui/react";

interface Props {
  game: Game;
}

const GameCard = () => {
  return (
    <>
      <Card>
        <Image />
      </Card>
    </>
  );
};

export default GameCard;
-------------------code----------------------

- now to set the src of image we back to the rog documentation 
https://api.rawg.io/docs/

- if we access Get a list of games then press the result we can see background_image and this is
what we will add to our interface

- so in useGames.ts we go to the interface Game and add background_image
-------------------code----------------------
export interface Game {
  id: number;
  name: string;
  background_image: string;
}
-------------------code----------------------

- now in our GameCard component we can set the image src to 
-------------------code----------------------
<>
  <Card>
    <Image src={game.background_image} />
  </Card>
</>
-------------------code----------------------

- next to it we add CardBody then inside it we add Heading with game.name 
-------------------code----------------------
<Card>
  <Image src={game.background_image} />
  <CardBody>
    <Heading>{game.name}</Heading>
  </CardBody>
</Card>
-------------------code----------------------

- so we built the shape of our component then we will improve our code little by little

- now we will test our code until this point 
- so inside the GameGrid component
we replace <ul> with SimpleGrid and add columns 3 with spacing of 10
then replace the <li> code with our GameCard and set the key and the game props

-------------------code----------------------
<SimpleGrid columns={3} spacing={10}>
  {games.map((game) => (
    <GameCard key={game.id} game={game} />
  ))}
</SimpleGrid>
-------------------code----------------------

- the first thing we want to fix is the border-radius and fix the sharp border of the card 

- to fix the radius 
-------------------code----------------------
<Card borderRadius={10}>
-------------------code----------------------

- now our bottom radius is fixed but not the top border coz the background_image is bigger 
than it`s container to fix this we need to set the overflow to hidden it just basic css 
-------------------code----------------------
<Card borderRadius={10} overflow="hidden">
-------------------code----------------------

- next we will fix our heading size is a little big  
PS: we can see the size in ChakaraUI documentation
-------------------code----------------------
<Heading fontSize="2xl">{game.name}</Heading>
-------------------code----------------------

- next thig to do is the columns number in small devices we don`t want always to render 3 columns 
instead we want two columns on tablet and one column for mobile devices and 3 for large devices
to do that 
-------------------code----------------------
<SimpleGrid columns={{ sm: 1, md: 2, lg: 3, xl: 5 }} spacing={10}>
-------------------code----------------------
now we test our code 

in small devices we can see our card is so close to the edge to we add 10px for padding
-------------------code----------------------
<SimpleGrid
        columns={{ sm: 1, md: 2, lg: 3, xl: 5 }}
        padding="10px"
        spacing={10}
      >
-------------------code----------------------

- now our code works fine so we commit our code to git 
"Building Game Card"

*** 12-_Displaying_Platform_Icons ***
- next we will display the games icons 

by using the dev tool [Network -> press the request -> preview] we check the request result and we can see 
every game has platform objects called first called parent_platform and the second platforms

ex: 
parent_platform: we have only one object that present playstaion switch PC
platforms: for diffrent versoin of playstaion ex: ps4, ps5 

in this object we have  parent_platforms which has array with platform object which has platform property which has property object

it`s called "design smells"  
which means:
These smells are the symptoms of a poor design. They should be cleaned up as soon as possible to stop them from spreading to other code.

-------------------code----------------------
parent_platforms: 
[{platform: {id: 1, name: "PC", slug: "pc"}},…]
0: {platform: {id: 1, name: "PC", slug: "pc"}}
platform: {id: 1, name: "PC", slug: "pc"}
id: 1
name: "PC"
slug: "pc"
-------------------code----------------------

but in this cases we have to deal with it.

now in our project the first thing we are add the platform_parent property to our Game interface
shortcut cmd + t or ctrl + t we can search class, fuctions, component, interface any Symbol in our project

now inside the useGame.ts we add 
-------------------code----------------------
export interface Game {
  id: number;
  name: string;
  background_image: string;
  parent_platforms:
}
-------------------code----------------------

but to set the type of parent_platforms we have to define another interface 
so we define platform interface 

-------------------code----------------------
interface Platfrom {
  id: number;
  name: string;
  slug: string;
}
-------------------code----------------------
now the tricky part is that the type of  parent_platforms: is not Platfrom[];

it`s array of object where each object has property called platform (coz we had design smells )
-------------------code----------------------
export interface Game {
  id: number;
  name: string;
  background_image: string;
  parent_platforms: { platform: Platfrom }[];
}
-------------------code----------------------

now we are going to render it step by step 
-------------------code----------------------
<Heading fontSize="2xl">{game.name}</Heading>
{game.parent_platforms.map((platform) => platform.platform.name)}
-------------------code----------------------
platform.platform.name to too ugly so we destruct (文割代入) platform
then we add it between Text component of ChakaraUI
-------------------code----------------------
{game.parent_platforms.map(({ platform }) => (
            <Text>platform.name</Text>
          ))}
-------------------code----------------------

now the next step is to render ths icons and for that we are going to user React Icon librariy
in the terminl we install 
-------------------code----------------------
npm i react-icons@4.7.1
-------------------code----------------------

to render the icon we need mapping between the platform name and the icon we don`t we want to mapping the icon in the same CardComponent 
component coz CardComponent is only related to the card implomantaion not the icons

so we will move all the logic of rendering the platform to seperate component

so in component folder we create component we called PlatfromIconList.tsx 

first we create Props to access the platforms
-------------------code----------------------
interface Props {
  platform: Platfrom[];
}
-------------------code----------------------

and now we need to export it from useGame.ts

after add Props to our Component we will test it intergation by add this code to it 
-------------------code----------------------
{game.parent_platforms.map(({ platform }) => (
            <Text>{platform.name}</Text>
          ))}
-------------------code----------------------


-------------------code----------------------
const PlatfromIconList = ({ platform }: Props) => {
  return (
    <>
      {game.parent_platforms.map(({ platform }) => (
        <Text>{platform.name}</Text>
      ))}
    </>
  );
};
-------------------code----------------------

now we don`t need  game.parent_platforms coz we maping only the platform so need either for destructuring
and import Text from ChakraUI we fix it 

-------------------code----------------------
const PlatfromIconList = ({ platform }: Props) => {
  return (
    <>
      {platform.map((platform) => (
        <Text>{platform.name}</Text>
      ))}
    </>
  );
};
-------------------code----------------------

no in the GameCard we use our PlatfromIconList Component
-------------------code----------------------
<PlatfromIconList
  platform={game.parent_platforms.map((p) => p.platform)}
/>
-------------------code----------------------

now we check if our code is workicg until this point 

now the last step is chage the platform labels {pc, Playstaion, ...} with icons  

now inside the PlatfromIconList we will import icons from React Icons libraries
-------------------code----------------------
import {
  FaWindows,
  FaPlaystation,
  FaXbox,
  FaApple,
  FaLinux,
  FaAndroid,
} from "react-icons/fa";
import { MdPhoneIphone } from "react-icons/md";
import { SiNintendo } from "react-icons/si";
import { BsGlobe } from "react-icons/bs";
-------------------code----------------------

now we have to map our names to icons we are not using if statment coz it`s ugly instead we are going to use
mapping object

now every platform has name and slug property 
for playstaion as example we have id: 2, name: "PlayStaion", slug: "playstaion"  the slug is more relayable coz is like id
names may changes 

-------------------code----------------------
const iconMap = {
    pc: FaWindows,
    playstation: FaPlaystation,
    xbox: FaXbox,
    nintendo: SiNintendo,
    mac: FaApple,
    linux: FaLinux,
    android: FaAndroid,
    ios: MdPhoneIphone,
    web: BsGlobe,
  };
  -------------------code----------------------

now we replace 
-------------------code----------------------
<Text>{platform.name}</Text>
with 

<Icon as={iconMap[platform.slug]}></Icon>
-------------------code----------------------

now we error Type error 
Element implicitly has an 'any' type because expression of type 'string' can't be used to index type

now instead of writing the type of each Element
-------------------code----------------------
  const iconMap: {ps: string,  ....} = {
    pc: FaWindows,
    playstation: FaPlaystation,
    xbox: FaXbox,
    nintendo: SiNintendo,
    mac: FaApple,
    linux: FaLinux,
    android: FaAndroid,
    ios: MdPhoneIphone,
    web: BsGlobe,
  };
-------------------code----------------------

shortcut way we grap the object inside arary [] and set all of them to same type
-------------------code----------------------
const iconMap: { [key: string] } = {
    pc: FaWindows,
    playstation: FaPlaystation,
    xbox: FaXbox,
    nintendo: SiNintendo,
    mac: FaApple,
    linux: FaLinux,
    android: FaAndroid,
    ios: MdPhoneIphone,
    web: BsGlobe,
  };
-------------------code----------------------

that`s means each key of iconMap is stirng 
now to fix the error we set 
-------------------code----------------------
const iconMap: { [key: string]: IconType } = {
  pc: FaWindows,
  playstation: FaPlaystation,
  xbox: FaXbox,
  nintendo: SiNintendo,
  mac: FaApple,
  linux: FaLinux,
  android: FaAndroid,
  ios: MdPhoneIphone,
  web: BsGlobe,
};
-------------------code----------------------

last thing we want to render the Icons horizontally so we add HStack
-------------------code----------------------
<HStack>
  {platform.map((platform) => (
    <Icon as={iconMap[platform.slug]}></Icon>
  ))}
</HStack>
-------------------code----------------------

now we test our code

we can see our icons is same color as the name of the Game which coz visual noise so we want to make our 
icons is darker to clean our interface 
-------------------code----------------------
<Icon as={iconMap[platform.slug]} color="gray.500"></Icon>
-------------------code----------------------

PS: to check the color of ChakaraUI we can go to ChakraUI doc => styled-system => theme

now the next thing we want to improve is the space between the Game name and the icon currently they are too close

-------------------code----------------------
<HStack marginY={1}>
-------------------code----------------------

PS: marginY={1}> => result is them.space * 1  {the default chakara UI them space is 4px}
but sometimes we have to handle spece manually so we use marginY="10 px" for example

now we commit our code "Displaying platform icons"


*** 13-_Displaying_Critic_Score ***

next we add path that contains the Score game metacritic (review)  (number between 0 to 100 )
the patch color dependent on the score high score should be green , medium score should be yellow 
now we don`t want to add this logic inside our game card component instead we will seperate it to another component


- we go to useGames.ts and add metacritic to our interface
-------------------code----------------------
export interface Game {
  id: number;
  name: string;
  background_image: string;
  parent_platforms: { platform: Platfrom }[];
  metacritic: number;
}
-------------------code----------------------

- next we create new component called CriticScore.tsx 

inside it we need prop to recive the score 
-------------------code----------------------
interface Props {
  score: number;
}
-------------------code----------------------

- to render the score we will use Badge component that defined in ChakaraUI
-------------------code----------------------
const CriticScore = ({ score }: Props) => {
  return (
    <>
      <Badge>{score}</Badge>
    </>
  );
};
-------------------code----------------------

now we check if it`s working 

- next we want to move the patch to the right next to game platform 
so we should grap the two component PlatfromIconList and CriticScore inisde horizontal stack

- next we justifyContent to space between (which means the space that left put between this elements)
-------------------code----------------------

<HStack justifyContent="space-between">
  <PlatfromIconList
    platform={game.parent_platforms.map((p) => p.platform)}
  />
  <CriticScore score={game.metacritic} />
</HStack>

-------------------code----------------------

- next we need to improve the local veiw of this patch 
we make it larger and add some horizontal padding and make the border more circle
-------------------code----------------------

<>
  <Badge fontSize="14px" paddingX={2} borderRadius="4px">
    {score}
  </Badge>
</>
-------------------code----------------------

- next we apply color if high score it will be green medium will be yellow otherwise still gray
let color = score > 75 ? "green" : score > 60 ? "yellow" : "";
-------------------code----------------------
let color = score > 75 ? "green" : score > 60 ? "yellow" : "";

return (
  <>
  <Badge
    colorScheme={color}
    fontSize="14px"
    paddingX={2}
    borderRadius="4px"
  >
    {score}
  </Badge>
</>
)
-------------------code----------------------

Ps: "colorScheme" is to give color to everything related to the Component backgroud and so
while "color" only give color to the number  

now we commit our code "Displaying Critic Score"
