*** 1-_What_Well_Build ***
we will build a tiny versoin of Rawg Site
https://rawg.io/

when we build project or feature(method)
first: Make it Work
second: Refactor the code 
third: Improve the code


*** 3-_Setting_Up_the_Project
we create React Project
npm create vite@4.1.0

we call the project: game-hub
we use TS then inside this project file we install all the dependencies
then run our project with npm run dev


- we connect our project to gitHub
1- initialize our project to  git repository
git init 
2- to add all the changes in our dirctory to staging 
git add .
to add our 
3- we commit our changes 
git commit -m "Initial commit"

4- we go to GitHub to create that repository (check the instruction of gitHub)

here we commit our code "create game-hub App"
*** 4-_Installing_Chakra_UI ***
there is too many libraries for styling UI (bootstrap, tailwind, chakraUI)
for this project we will use ChakraUI

https://v2.chakra-ui.com/

PS: 
1- to install it we press go started and chose the installion for Vite
2- we will not do the optional things right now ex: Customizing theme (Optional)
-------------------code----------------------
when we add 
import { ChakraProvider } from "@chakra-ui/react";

it`s better to orginze our import statment code 
ex: 
- import the React libraries first 
- import the third libraries
- import the local files 
-------------------code----------------------

now after read the installion
we check if ChakraUI is installed by adding a button 

after remove everything in the App.tsx
we add button (method: ChakraUI site)

we see u ugly blue border around the button when we hover
coz we havn`t remove the the code from the index.css (so we remove all the style the code inside it to fix that)

until this point we check the git tree of of our changes (always make sure to do that before commit to avoid commit unnecessary code )
and we commnt our code  "install ChakraUI" 

to check our commit until this point we type
git log --oneline 

PS:to check the first three commit only 
git log --oneline -n 3 


5-_Creating_a_Responsive_Layout
we want to add navbar to the top and side panal to the left and the main area in the middle

to do that we are going to use Grid component:
first we remove the everything from the App component coz we don`t need it any more

we use Grid component from the ChakraUI

<Grid templateAreas={``}></Grid>

PS: we used `` coz inside it we will add double string quotation　
ex: `"" ""`

now we want Nav on the top and side menu on the the left and main area
like this 
-------------------code----------------------
<Grid
        templateAreas={`"nav nav" 
                        "aside main"`}
      ></Grid>
-------------------code----------------------

now inside the Grid component we create GridItem and give an area from our four areas ()
<GridItem area={"nav"} bg={"coral"}>
          Nav
</GridItem>

and give it a bg (backgroud) color to see it

we duplicate this component  with 3 times Nav  Aside with our four areas

-------------------code----------------------
 <Grid templateAreas={`"nav nav" "aside main"`}>
  <GridItem area={"nav"} bg={"coral"}>
    Nav
  </GridItem>
  <GridItem area={"aside"} bg={"gold"}>
    Aside
  </GridItem>
  <GridItem area={"main"} bg={"dodgerblue"}>
    Main
  </GridItem>
</Grid>
-------------------code----------------------

now on the mobile devices we want to hide the aside panal to do that 
in the 
-------------------code----------------------
templateAreas={`"nav nav" "aside main"`}
-------------------code----------------------

we change string of templateAreas to object and inside it we can define the template area for each screen size
PS: for better understaing visit Chakra UI then access to "Styled System" then click on "Responsive Styles" we can check the break points
https://v2.chakra-ui.com/docs/styled-system/responsive-styles

in our Project we will design our UI for two sizes normal and mobile
-------------------code----------------------
templateAreas={{
          base: `"nav" "main"`,
          lg: `"nav nav" "aside main"`,
        }}
-------------------code----------------------

we check our layout on the Devtool 
we see the aside template still there coz we still render it on the screen 

to make sure that Aside GridItem only render on the base tamplate
we should wrap it with Show component and give a property of "above"
-------------------code----------------------
<Show above="lg">
  <GridItem area={"aside"} bg={"gold"}>
    Aside
  </GridItem>
</Show>
-------------------code----------------------

here we commit our code 
"Build a responsive layout"


*** 6-_Building_the_Navigation_Bar ***
now we will wikr only on the basic layout for the navigation bar 
this how we build a project start with simple functionality then we move to the next step 

- we create components folder inside the src folder 
inside it we create NavBar.tsx and we use rafce
we remove unused import React statment

- now we want to layout our items in this component horizontally 
to do that we can use Component in ChakraUI called HStack (whcih means horizontal stack)

- inside the HStach component we use Image component by typing Image we have two Image components
we use the Image instance of ChakraUI
*********************
PS: to see that in options we type <Image munally 
we have two instances one for normal interface and one is the Image of ChakaraUI
*********************

- we download the logo image from from GameHub Resources.zip and move the logo.webp to the assets
ps: webp image are high optimize images for web 

- in Image ChakaraUI Component we can`t use src={} with path intead we import the image as 
JS module and use the imported object inside the src 
-------------------code---------------------- 
import logo from "../assets/logo.webp";
<Image src={logo}></Image>
-------------------code----------------------

- now we add our NavBar Component in the App.tsx 
we change the NavBar word with NavBar Component

- we check our code and we see that our logo is two big so we need to resize it using boxSize
-------------------code----------------------
<Image src={logo} boxSize="60px"></Image>
-------------------code----------------------

- we are using horizontal stack now if we add text in our navbar it should appear after our image
to check that we add a Text component (instance of ChakaraUI)
-------------------code----------------------
<HStack>
  <Image src={logo} boxSize="60px"></Image>
  <Text>NavBar</Text>
</HStack>
-------------------code----------------------

- now normally after building our layout component we remove the backgroud color coz we don`t need to check the layout
anymore 
so in the App.tsx we remove 
-------------------code----------------------
 bg={"coral"}
-------------------code----------------------

now after review our code now we add commit to our repository
"Build a NavBar"


*** 7-_Implementing_the_Dark_Mode ***
in the documentation of the ChakaraUI we search for "color mode" in this page we can read how color 
mode works in ChakaraUI to Implement the dark mode we have to do some steps we 
don`t have to memorize it we can see it in the documentation.

- in the src folder we create a file we called theme.ts
here we are going to customize our default theme whcih come with ChakaraUI
we copy all the code from the  and change the initialColorMode to dark 
https://v2.chakra-ui.com/docs/styled-system/color-mode

- we go to main.ts and import the theme.ts
first we import theme
then we have to use it in two places 
-------------------code----------------------
import theme from "../src/them";

ChakraProvider theme={theme}>   /=> first place
<ColorModeScript /=> second place
  initialColorMode={theme.config.initialColorMode}
></ColorModeScript>
<App />
-------------------code----------------------

- now if we refresh our page the page is still light coz ChakaraUI stores the selected mode 
in the local storge so it can remmeber it in the future sessions

we can check that with dev tool and went to Application then Local Storage
and delete the "light" key 

- now if we refreshed the page we got black background 
now we checked the Local Storage we can see it "dark" 

here we commit our code 





*** 8-_Building_the_Color_Mode_Switch ***

now we will create switch button to change the color mode between light and dark modes

now in the component folder we create ColorModeSwitch.tsx 
inside it we create horizontal stack component coz we need the label to be next to it
ex:
○ Change Mode

-------------------code----------------------
<HStack>
  <Switch></Switch>
  <Text>Dark Mode</Text>
</HStack>
-------------------code----------------------

to work with color mode we have to use custom Hook that defined in ChakaraUI 

first we search on google 
useColorMode 
and in documentation

https://v2.chakra-ui.com/docs/styled-system/color-mode#changing-color-mode

so according to the documentation:
- first we import useColorMode hook from the ChakaraUI
- then we called useColorMode  and Destructuring (分割代入) toggleColorMode and colorMode
-------------------code----------------------
Destructuring object 分割代入は、中カッコ{}に取り出したいプロパティを指定することで、
プロパティ名と同じ名前の変数が作れます。次の分割代入のサンプルコードは、
上のプロパティアクセサーを使ったコードと同等の処理になります。

const item = { price: 100 };
const { price } = item;
// 上は const price = item.price; と同等の処理

複数のプロパティを取り出す

分割代入は、複数のプロパティを一度に取り出すこともできます。その場合、取り出したいプロパティを中カッコに列挙します。

const obj = { a: 1, b: 2 };
const { a, b } = obj;

引用+詳細：
https://typescriptbook.jp/reference/values-types-variables/object/destructuring-assignment-from-objects
-------------------code----------------------

- then we modify the switch component 
-------------------code----------------------
<Switch
  isChecked={colorMode == "dark"}
  onChange={toggleColorMode}
></Switch>
-------------------code----------------------


- now we add the ColorModeSwitch component to our Nav component
and replace the 
-------------------code----------------------
<Text>NavBar</Text>
-------------------code----------------------
with 
-------------------code----------------------
<ColorModeSwitch />
-------------------code----------------------
finally we remove unused components

- and we test our code until this point 

now we don`t need the background color of Aside and Main Grid so we remove their bg  
-------------------code----------------------
bg={"gold"}
bg={"dodgerblue"}
-------------------code----------------------

- to make our switch button look more beautiful we add colorScheme to Switch Component
-------------------code----------------------
<Switch
  colorScheme="green"
  isChecked={colorMode == "dark"}
  onChange={toggleColorMode}
></Switch>
-------------------code----------------------

- finally we want to push the switch button the right side to do that 
we go to our NavBar component this work exacly like flex container 
-------------------code----------------------
<HStack justifyContent={"space-between"}>
-------------------code----------------------

- now our button is close to the right side but it so close to the edge of the screen
so we need to apply some padding to the HStach component
-------------------code----------------------
<HStack justifyContent={"space-between"} padding="10px">
-------------------code----------------------

now we review our code and commit it to our repository
"Build the color mode switch"

*** 9-_Fetching_the_Games ***
now we will fetch the game from rawg.io 

- first sign up
- get API KEY 

- install axios for sending api requests

- now we need to create axios instance with custom configration, in that configration we will 
include that API-KEY whcih we copied 

- inside the src we create services folder 
inside we create api-client.ts 

- inside the api-client first we import axios on the top then we call the create method to 
create axios instance with custom configration inside we create params object and set the key to the API-Key from 
the rawg.io
-------------------code----------------------
import axios from "axios";

axios.create({
  params: {
    key: "API-KEY",
  },
});
-------------------code----------------------

- with this configration our API-Key will be included in every HTTP request we send

*********************************
our API KEY should not pushed to the git hub so we should pass at environment variable
to do that:
1- create .env file in the root of the project 
2- add .env to .gitignore
3- we pass the Key as VITE_SOME_NAME
ps: we shuold start with VITE
ex: VITE_API_KEY
4- we call it using 
import.meta.env.VITE_API_KEY

*********************************

- to we set the baseURL:
first we go to the https://api.rawg.io/docs/
we have multi endpoints 
we go to the games -> get a list of games 
if we scrol down we can see the object that come back from the server (respone)
-------------------code----------------------
{
"count": 0,
"next": "http://example.com",
"previous": "http://example.com",
"results": [
{}
]
}
-------------------code----------------------
if we click on GET/games we can see the full URL 
https://api.rawg.io/api/games
to use as baseURL we need remove the games so we have 
https://api.rawg.io/api

- now we need to export as default object
-------------------code----------------------
import axios from "axios";

export default axios.create({
  baseURL: "https://api.rawg.io/api/games",
  params: {
    key: "c7b18323a47d40c394ea5b019646b1f5",
  },
});
-------------------code----------------------

- now we create a new component called GameGrid
- in this component we state hook to store our games object (data from the server)
-------------------code----------------------
const [games, setGames] = useState();
-------------------code----------------------

- then we need to store error of we had errors during fetching the game 
-------------------code----------------------
const [error, setError] = useState();
-------------------code----------------------

- then we should use Effect hool to send fetch request to the server/backend
and inside we need to use apiClient so we import it from api-client.ts

-------------------code----------------------
import apiClient from "../services/api-client";
-------------------code----------------------

- now inside the useEffect we sent get request to ("/games") and if the responese goes well 

-------------------code----------------------
useEffect(() => {
    apiClient.get("/games").then((res) => setGames());
  });
-------------------code----------------------

- we need to define the interface to grap the Response objects (count, next, previous, results)
in this project we will not care a bout the (next, previous) at this point only we need number and results

-------------------code----------------------
interface FetchGamesResponse {
  count: number;
  results;
}
-------------------code----------------------

- now lets see what data we have in the response
in https://api.rawg.io/docs/#operation/games_list if press on results 
we can see the data like [id, slug, name, and so...]
for now we only want to grap the [id, name ] later we will add another properties when we need them 
so we are not write code we will not use right now 
-------------------code----------------------
interface Game {
  id: number;
  name: string;
}
-------------------code----------------------
- withthat we can see we set the results to type Game Array

-------------------code----------------------
interface FetchGamesResponse {
  count: number;
  results: Game[];
}
-------------------code----------------------

- now when we send get request to server we use <> to provide  generic type argument that is FetchGamesResponse
with we can know the shape of res object {AxiosResponse<FetchGamesResponse,}, so if type setGames(res.) we can see 
the property of the response that comes with axios here we need to access data property so we read the body
of the responese setGames(res.data.) and here we can see the property that comes with the API so we have [count and results]
-------------------code----------------------
useEffect(() => {
    apiClient
      .get<FetchGamesResponse>("/games")
      .then((res) => setGames(res.data.results));
  });
-------------------code----------------------

- now we compilation error coz we set the useState of games to empty Array
so we have to tell the TS compiler that it`s game Array

-------------------code----------------------
const [games, setGames] = useState<Game[]>([]);
-------------------code----------------------

- now what if we got an error, so by using catch method we setError to err.message 
-------------------code----------------------
useEffect(() => {
    apiClient
      .get<FetchGamesResponse>("/games")
      .then((res) => setGames(res.data.results))
      .catch((err) => setError(err.message));
  });
-------------------code----------------------

- now to check id our implomantaion is currect we render the games names 

-------------------code----------------------
<ul>
  {games.map((game) => (
    <li key={game.id}>{game.name}</li>
  ))}
</ul>
-------------------code----------------------

- in the App.tsx we instead we change Main with GameGrid


- now what if we have an error 
we need to render it on the top of our markup
-------------------code----------------------
{error && <Text>{error}</Text>}
-------------------code----------------------

- we simulate error our test our error rendering error 
-------------------code----------------------
.get<FetchGamesResponse>("/xgames") 
-------------------code----------------------

- until this point now we commit our code 
"Fetching Games from the server"



*** 10-_Creating_a_Custom_Hook_for_Fetching_Games ***
now in our GameGrid Component we are working with the backend ex:
we have get method an later we have to use controler abort
so our component knows about backend and frondend as the same time
we need to make our component only responsible for our frontend (return markup and handle events) 

here we have two options:
1- move the logic that has HTTP request (get) to servise (ex: service/games-service.ts)
like we do in the previous section.

2- the next option is to move all the entire logic (all useStates and useEffect) to custom hook 

so we can create custom hook not for only specific handling but also to moduler our code and make it more useble
so we will create custom Hook for fetching the games 

- inside the src folder we create hooks folder 

- inside the hooks folder we create useGames.ts

first we create variables called useGames and export it
-------------------code----------------------
const useGames = () => {
  
};

export default useGames;
-------------------code----------------------

-  now we move all the hooks from the GameGrid.tsx to our custom hook 
-------------------code----------------------
const useGames = () => {
  const [games, setGames] = useState<Game[]>([]);
  const [error, setError] = useState("");

  useEffect(() => {
    apiClient
      .get<FetchGamesResponse>("/games")
      .then((res) => setGames(res.data.results))
      .catch((err) => setError(err.message));
  }, []);
};

export default useGames;
-------------------code----------------------

- now we will resolve the errors 
- first we move the Game and FetchGamesResponse interface to our custom hook and export them 
- then we move the useState/useEffect import statment and apiClient to the custom hook 
- finally we have to return the error and games object to use them in our component

-------------------code----------------------
import { useEffect, useState } from "react";
import apiClient from "../services/api-client";

export interface Game {
  id: number;
  name: string;
}
export interface FetchGamesResponse {
  count: number;
  results: Game[];
}

const useGames = () => {
  const [games, setGames] = useState<Game[]>([]);
  const [error, setError] = useState("");

  useEffect(() => {
    apiClient
      .get<FetchGamesResponse>("/games")
      .then((res) => setGames(res.data.results))
      .catch((err) => setError(err.message));
  }, []);

  return { games, error };
};

export default useGames;
-------------------code----------------------

- now we go back to our component and clean some code 
- first we remove unnecessary import statment
- we import useGames hook and retrun games, and error objects

-------------------code----------------------
const { games, error } = useGames();
-------------------code----------------------

- now our component is cleaner and don`t know anything a bout HTTP request and only returning markup

- next step to handle out cancelation 
-------------------code----------------------
1- const contoller = new AbortController();
2- ("/games", { signal: contoller.signal })
3- return () => contoller.abort();
-------------------code----------------------

- now in our markup we see canceled as the top 
*********************
canceled

Grand Theft Auto V
The Witcher 3: Wild Hunt
Portal 2
Counter-Strik
*********************

to fix it 
-------------------code----------------------
.catch((err) => {
        if (err instanceof CanceledError) return;
        setError(err.message);
      })
-------------------code----------------------

- now if we refreshed our Browser we can see in the Network tab that we have two requests to the games api
 the first one canceled coz our react unmount our component at the first time coz the strict mode

- now we commit our code untile this point
"Create a custom hook to fetch the games"


*** 11-_Building_Game_Cards ***

next step is replace the ● the points with Game cards
- we create GameCard.tsx 

- next we should pass a game object as props for this component

interface
-------------------code----------------------
interface Props {
  game: Game;
}
-------------------code----------------------

PS: but we need to import Game interface form our custom hook
-------------------code---------------------- 
import { Game } from "../hooks/useGames";
-------------------code----------------------

PS: importing interface from custom hook is kind ugly but we will fix it later

- after creating Props we are going to pass Props as argument
and we will return Card Component (import from Chakra UI ) and inside it Image component from ChakaraUI either.

-------------------code----------------------
import { Game } from "../hooks/useGames";
import { Card, Image } from "@chakra-ui/react";

interface Props {
  game: Game;
}

const GameCard = () => {
  return (
    <>
      <Card>
        <Image />
      </Card>
    </>
  );
};

export default GameCard;
-------------------code----------------------

- now to set the src of image we back to the rog documentation 
https://api.rawg.io/docs/

- if we access Get a list of games then press the result we can see background_image and this is
what we will add to our interface

- so in useGames.ts we go to the interface Game and add background_image
-------------------code----------------------
export interface Game {
  id: number;
  name: string;
  background_image: string;
}
-------------------code----------------------

- now in our GameCard component we can set the image src to 
-------------------code----------------------
<>
  <Card>
    <Image src={game.background_image} />
  </Card>
</>
-------------------code----------------------

- next to it we add CardBody then inside it we add Heading with game.name 
-------------------code----------------------
<Card>
  <Image src={game.background_image} />
  <CardBody>
    <Heading>{game.name}</Heading>
  </CardBody>
</Card>
-------------------code----------------------

- so we built the shape of our component then we will improve our code little by little

- now we will test our code until this point 
- so inside the GameGrid component
we replace <ul> with SimpleGrid and add columns 3 with spacing of 10
then replace the <li> code with our GameCard and set the key and the game props

-------------------code----------------------
<SimpleGrid columns={3} spacing={10}>
  {games.map((game) => (
    <GameCard key={game.id} game={game} />
  ))}
</SimpleGrid>
-------------------code----------------------

- the first thing we want to fix is the border-radius and fix the sharp border of the card 

- to fix the radius 
-------------------code----------------------
<Card borderRadius={10}>
-------------------code----------------------

- now our bottom radius is fixed but not the top border coz the background_image is bigger 
than it`s container to fix this we need to set the overflow to hidden it just basic css 
-------------------code----------------------
<Card borderRadius={10} overflow="hidden">
-------------------code----------------------

- next we will fix our heading size is a little big  
PS: we can see the size in ChakaraUI documentation
-------------------code----------------------
<Heading fontSize="2xl">{game.name}</Heading>
-------------------code----------------------

- next thig to do is the columns number in small devices we don`t want always to render 3 columns 
instead we want two columns on tablet and one column for mobile devices and 3 for large devices
to do that 
-------------------code----------------------
<SimpleGrid columns={{ sm: 1, md: 2, lg: 3, xl: 5 }} spacing={10}>
-------------------code----------------------
now we test our code 

in small devices we can see our card is so close to the edge to we add 10px for padding
-------------------code----------------------
<SimpleGrid
        columns={{ sm: 1, md: 2, lg: 3, xl: 5 }}
        padding="10px"
        spacing={10}
      >
-------------------code----------------------

- now our code works fine so we commit our code to git 
"Building Game Card"

*** 12-_Displaying_Platform_Icons ***
- next we will display the games icons 

by using the dev tool [Network -> press the request -> preview] we check the request result and we can see 
every game has platform objects called first called parent_platform and the second platforms

ex: 
parent_platform: we have only one object that present playstaion switch PC
platforms: for diffrent versoin of playstaion ex: ps4, ps5 

in this object we have  parent_platforms which has array with platform object which has platform property which has property object

it`s called "design smells"  
which means:
These smells are the symptoms of a poor design. They should be cleaned up as soon as possible to stop them from spreading to other code.

-------------------code----------------------
parent_platforms: 
[{platform: {id: 1, name: "PC", slug: "pc"}},…]
0: {platform: {id: 1, name: "PC", slug: "pc"}}
platform: {id: 1, name: "PC", slug: "pc"}
id: 1
name: "PC"
slug: "pc"
-------------------code----------------------

but in this cases we have to deal with it.

now in our project the first thing we are add the platform_parent property to our Game interface
shortcut cmd + t or ctrl + t we can search class, fuctions, component, interface any Symbol in our project

now inside the useGame.ts we add 
-------------------code----------------------
export interface Game {
  id: number;
  name: string;
  background_image: string;
  parent_platforms:
}
-------------------code----------------------

but to set the type of parent_platforms we have to define another interface 
so we define platform interface 

-------------------code----------------------
interface Platform {
  id: number;
  name: string;
  slug: string;
}
-------------------code----------------------
now the tricky part is that the type of  parent_platforms: is not Platform[];

it`s array of object where each object has property called platform (coz we had design smells )
-------------------code----------------------
export interface Game {
  id: number;
  name: string;
  background_image: string;
  parent_platforms: { platform: Platform }[];
}
-------------------code----------------------

now we are going to render it step by step 
-------------------code----------------------
<Heading fontSize="2xl">{game.name}</Heading>
{game.parent_platforms.map((platform) => platform.platform.name)}
-------------------code----------------------
platform.platform.name to too ugly so we destruct (文割代入) platform
then we add it between Text component of ChakaraUI
-------------------code----------------------
{game.parent_platforms.map(({ platform }) => (
            <Text>platform.name</Text>
          ))}
-------------------code----------------------

now the next step is to render ths icons and for that we are going to user React Icon librariy
in the terminl we install 
-------------------code----------------------
npm i react-icons@4.7.1
-------------------code----------------------

to render the icon we need mapping between the platform name and the icon we don`t we want to mapping the icon in the same CardComponent 
component coz CardComponent is only related to the card implomantaion not the icons

so we will move all the logic of rendering the platform to seperate component

so in component folder we create component we called PlatformIconList.tsx 

first we create Props to access the platforms
-------------------code----------------------
interface Props {
  platforms: Platform[];
}
-------------------code----------------------

and now we need to export it from useGame.ts

after add Props to our Component we will test it intergation by add this code to it 
-------------------code----------------------
{game.parent_platforms.map(({ platform }) => (
            <Text>{platform.name}</Text>
          ))}
-------------------code----------------------


-------------------code----------------------
const PlatformIconList = ({ platforms }: Props) => {
  return (
    <>
      {game.parent_platforms.map(({ platform }) => (
        <Text>{platform.name}</Text>
      ))}
    </>
  );
};
-------------------code----------------------

now we don`t need  game.parent_platforms coz we maping only the platform so need either for destructuring
and import Text from ChakraUI we fix it 

-------------------code----------------------
const PlatformIconList = ({ platforms }: Props) => {
  return (
    <>
      {platforms.map((platform) => (
        <Text>{platform.name}</Text>
      ))}
    </>
  );
};
-------------------code----------------------

no in the GameCard we use our PlatformIconList Component
-------------------code----------------------
<PlatformIconList
  platforms={game.parent_platforms.map((p) => p.platform)}
/>
-------------------code----------------------

now we check if our code is workicg until this point 

now the last step is chage the platform labels {pc, Playstaion, ...} with icons  

now inside the PlatformIconList we will import icons from React Icons libraries
-------------------code----------------------
import {
  FaWindows,
  FaPlaystation,
  FaXbox,
  FaApple,
  FaLinux,
  FaAndroid,
} from "react-icons/fa";
import { MdPhoneIphone } from "react-icons/md";
import { SiNintendo } from "react-icons/si";
import { BsGlobe } from "react-icons/bs";
-------------------code----------------------

now we have to map our names to icons we are not using if statment coz it`s ugly instead we are going to use
mapping object

now every platform has name and slug property 
for playstaion as example we have id: 2, name: "PlayStaion", slug: "playstaion"  the slug is more relayable coz is like id
names may changes 

-------------------code----------------------
const iconMap = {
    pc: FaWindows,
    playstation: FaPlaystation,
    xbox: FaXbox,
    nintendo: SiNintendo,
    mac: FaApple,
    linux: FaLinux,
    android: FaAndroid,
    ios: MdPhoneIphone,
    web: BsGlobe,
  };
  -------------------code----------------------

now we replace 
-------------------code----------------------
<Text>{platform.name}</Text>
with 

<Icon as={iconMap[platform.slug]}></Icon>
-------------------code----------------------

now we error Type error 
Element implicitly has an 'any' type because expression of type 'string' can't be used to index type

now instead of writing the type of each Element
-------------------code----------------------
  const iconMap: {ps: string,  ....} = {
    pc: FaWindows,
    playstation: FaPlaystation,
    xbox: FaXbox,
    nintendo: SiNintendo,
    mac: FaApple,
    linux: FaLinux,
    android: FaAndroid,
    ios: MdPhoneIphone,
    web: BsGlobe,
  };
-------------------code----------------------

shortcut way we grap the object inside arary [] and set all of them to same type
-------------------code----------------------
const iconMap: { [key: string] } = {
    pc: FaWindows,
    playstation: FaPlaystation,
    xbox: FaXbox,
    nintendo: SiNintendo,
    mac: FaApple,
    linux: FaLinux,
    android: FaAndroid,
    ios: MdPhoneIphone,
    web: BsGlobe,
  };
-------------------code----------------------

that`s means each key of iconMap is stirng 
now to fix the error we set 
-------------------code----------------------
const iconMap: { [key: string]: IconType } = {
  pc: FaWindows,
  playstation: FaPlaystation,
  xbox: FaXbox,
  nintendo: SiNintendo,
  mac: FaApple,
  linux: FaLinux,
  android: FaAndroid,
  ios: MdPhoneIphone,
  web: BsGlobe,
};
-------------------code----------------------

last thing we want to render the Icons horizontally so we add HStack
-------------------code----------------------
<HStack>
  {platform.map((platform) => (
    <Icon as={iconMap[platform.slug]}></Icon>
  ))}
</HStack>
-------------------code----------------------

now we test our code

we can see our icons is same color as the name of the Game which coz visual noise so we want to make our 
icons is darker to clean our interface 
-------------------code----------------------
<Icon as={iconMap[platform.slug]} color="gray.500"></Icon>
-------------------code----------------------

PS: to check the color of ChakaraUI we can go to ChakraUI doc => styled-system => theme

now the next thing we want to improve is the space between the Game name and the icon currently they are too close

-------------------code----------------------
<HStack marginY={1}>
-------------------code----------------------

PS: marginY={1}> => result is them.space * 1  {the default chakara UI them space is 4px}
but sometimes we have to handle spece manually so we use marginY="10 px" for example

now we commit our code "Displaying platform icons"


*** 13-_Displaying_Critic_Score ***

next we add path that contains the Score game metacritic (review)  (number between 0 to 100 )
the patch color dependent on the score high score should be green , medium score should be yellow 
now we don`t want to add this logic inside our game card component instead we will seperate it to another component


- we go to useGames.ts and add metacritic to our interface
-------------------code----------------------
export interface Game {
  id: number;
  name: string;
  background_image: string;
  parent_platforms: { platform: Platform }[];
  metacritic: number;
}
-------------------code----------------------

- next we create new component called CriticScore.tsx 

inside it we need prop to recive the score 
-------------------code----------------------
interface Props {
  score: number;
}
-------------------code----------------------

- to render the score we will use Badge component that defined in ChakaraUI
-------------------code----------------------
const CriticScore = ({ score }: Props) => {
  return (
    <>
      <Badge>{score}</Badge>
    </>
  );
};
-------------------code----------------------

now we check if it`s working 

- next we want to move the patch to the right next to game platform 
so we should grap the two component PlatformIconList and CriticScore inisde horizontal stack

- next we justifyContent to space between (which means the space that left put between this elements)
-------------------code----------------------

<HStack justifyContent="space-between">
  <PlatformIconList
    platform={game.parent_platforms.map((p) => p.platform)}
  />
  <CriticScore score={game.metacritic} />
</HStack>

-------------------code----------------------

- next we need to improve the local veiw of this patch 
we make it larger and add some horizontal padding and make the border more circle
-------------------code----------------------

<>
  <Badge fontSize="14px" paddingX={2} borderRadius="4px">
    {score}
  </Badge>
</>
-------------------code----------------------

- next we apply color if high score it will be green medium will be yellow otherwise still gray
let color = score > 75 ? "green" : score > 60 ? "yellow" : "";
-------------------code----------------------
let color = score > 75 ? "green" : score > 60 ? "yellow" : "";

return (
  <>
  <Badge
    colorScheme={color}
    fontSize="14px"
    paddingX={2}
    borderRadius="4px"
  >
    {score}
  </Badge>
</>
)
-------------------code----------------------

Ps: "colorScheme" is to give color to everything related to the Component backgroud and so
while "color" only give color to the number  

now we commit our code "Displaying Critic Score"

*** 14-_Getting_Optimized_Images ***

- the image that we have until this point are actually very big (size) so for the Users of slow connection loading
this images will take a long time.

- so we will optimize the image size to get faster load

we go to dev tool => Network =>  and filter by image by tap at img 

we chose an image and with right click we copy the image url  and we paste it on new tab
-------------------code----------------------
https://media.rawg.io/media/games/4be/4be6a6ad0364751a96229c56bf69be59.jpg
-------------------code----------------------
we can see the image is big so no need to download big image to put inside a small game card 

rawg.io support crop images so 
after media keyword we cans set the size dimensions 
ex: and add crop/600/400 after media 
-------------------code----------------------
https://media.rawg.io/media/crop/600/400/games/4be/4be6a6ad0364751a96229c56bf69be59.jpg
-------------------code----------------------

- to render optimized images by make our image smaller we need to add crop/600/400 to the image url that we take fromt the api 
we don`t want to optimized images in our GameCard component instead of that we will do it seperately 

so we need service to modify the image url so inside the service folder we create image-url.ts

first we define the getCroppedImageUrl method that take the image url and return a smaller image url
then we export it 
-------------------code----------------------
const getCroppedImageUrl = (url: string) => {

};

export default getCroppedImageUrl;
-------------------code----------------------

- next we should find the index of media keyword (coz we want to add the crop after it) and save inside 
variable we called index
-------------------code----------------------
const index = url.indexOf("media/");
-------------------code----------------------

now to insert the crop parameter after media we are gonna use the slice method 
first we want to grap all the char from the begining until the media keyword
-------------------code----------------------
url.slice(0, index);
-------------------code----------------------

- now coz we want the crop parameter after media we add the length of the media to the index 
-------------------code----------------------
const index = url.indexOf("media/") + "media/".length;
url.slice(0, index);
-------------------code----------------------

- now coz we used "media/" twice it`s better to put in in constant we called target 
-------------------code----------------------
const getCroppedImageUrl = (url: string) => {
  const target = "media/";
  const index = url.indexOf(target) + target.length;
  url.slice(0, index);
};
-------------------code----------------------

- until this point we got the char from the url until "media" keyword

now we add "crop/600/400/"
-------------------code----------------------
url.slice(0, index) + "crop/600/400/" ;
-------------------code----------------------

- then we should add the rest of the url to our new url 
-------------------code----------------------
url.slice(0, index) + "crop/600/400/" + url.slice(index);
-------------------code----------------------

in otherword:
our orl url:
https://media.rawg.io/media/games/4be/4be6a6ad0364751a96229c56bf69be59.jpg


url.slice(0, index) => "https://media.rawg.io/media/"
url.slice(0, index) + "crop/600/400/" => "https://media.rawg.io/media/rop/600/400"
url.slice(index) => "/games/4be/4be6a6ad0364751a96229c56bf69be59.jpg"

result:
https://media.rawg.io/media/crop/600/400/games/4be/4be6a6ad0364751a96229c56bf69be59.jpg

- finally we return it 
-------------------code----------------------
const getCroppedImageUrl = (url: string) => {
  const target = "media/";
  const index = url.indexOf(target) + target.length;
  return url.slice(0, index) + "crop/600/400/" + url.slice(index);
};

export default getCroppedImageUrl;
-------------------code----------------------

now we to test our implomantaion we go to the GameCard.tsx and apply our method 
-------------------code----------------------
<Image src={getCroppedImageUrl(game.background_image)} />
-------------------code----------------------

from Dev tool => Network => img 
then copy the url of an image and check if it smaller 

now we commit our code
"Get optimized images"

*** 15-_Improving_User_Experience_with_Loading_Skeletons ***

we will add loading skeletons to our page so while we wait for backend until showing the games we are going
to show loading skeletons

first we need to track the loading state in our useGame.ts hook 
so we insilize a value to false and called isLoading 
-------------------code----------------------
const [isLoading, setLoading] = useState(false);
-------------------code----------------------

- first we set it setLoading to false before calling the api calling to true
- then set off when there the result comes or if an error happens
- finally we return isLoading 
-------------------code----------------------
const useGames = () => {
  const [games, setGames] = useState<Game[]>([]);
  const [error, setError] = useState("");
  const [isLoading, setLoading] = useState(false);

  setLoading(true);
  useEffect(() => {
    const contoller = new AbortController();
    apiClient
      .get<FetchGamesResponse>("/games", { signal: contoller.signal })
      .then((res) => {
        setGames(res.data.results);
        setLoading(false);
      })
      .catch((err) => {
        if (err instanceof CanceledError) return;
        setError(err.message);
        setLoading(false);
      });

    return () => contoller.abort();
  }, []);

  return { games, error, isLoading };
};
-------------------code----------------------

- now to render a skeletons we should render a seperate component
that component is gonna looks like game card but it`s not a game card 

- in otherword: 
we are going to render game card when we have an object from backend otherwise w will render skeletons (empty card) 
while we are waiting 

- so we create component for the empty card we called GameCardSkeleton.tsx

- now in our GameCardSkeleton.tsx we will render Card at first but we will not render an image instead
we will render a skeletons
-------------------code----------------------
return (
    <>
      <Card>
        <Skeleton height="200px" />
      </Card>
    </>
  );
-------------------code----------------------

- then we add CardBody as the same shape of our game card
-------------------code----------------------
return (
    <>
      <Card>
        <Skeleton height="200px" />
        <CardBody>
          <SkeletonText />
        </CardBody>
      </Card>
    </>
  );
-------------------code----------------------

- now our skeleton is ready and we will useit in our GameGrid.tsx
first we add iseLoading
-------------------code---------------------
const { games, error, isLoading } = useGames();
-------------------code---------------------

now to render a skeleton we need an array with 6 item (otherword we render 6 skeletons (empty card) while loading)
so we create an array with 6 elements or any number you like (for me 15)
-------------------code---------------------
const skeletons = [1, 2, 3, 4, 5, 6];
-------------------code---------------------

after creating array of 6 elements we need to render this 6 item as 6 skeletons of the isLoading is true
-------------------code---------------------
{isLoading &&
          skeletons.map((skeleton) => <GameCardSkeleton key={skeleton} />)}
-------------------code---------------------

- now we test our code and we can see we have a layout issue coz our skeletons
doesn`t have same width as our cards so we will try to make the width our card component
as the same here we try 250px
in our GameCard and GameCardSkeleton
GameCard
-------------------code---------------------
<Card width="250px">
-------------------code---------------------
GameCardSkeleton
-------------------code---------------------
<Card width="250px" borderRadius={10} overflow="hidden">
-------------------code---------------------

- now we have an issue we declure two related width 250px not dynamically in too places 
so if our styles in the future change and need to change the width we have to remmber to chnage it 
in tow places 
so we should fix this issue (but later) after finish deploying 
first we make our code workds then we refactor it

- now we test our code and we can see that the loading skeletons border not the same 
radius as the game card to fix that 

as we we can see  are diffrent so we should apply the same styles to each other
GameCard
-------------------code---------------------
<Card width="250px">
-------------------code---------------------
GameCardSkeleton
-------------------code---------------------
<Card width="250px" borderRadius={10} overflow="hidden">
-------------------code---------------------

we fix to it 
-------------------code---------------------
<Card width="250px" borderRadius={10} overflow="hidden">
-------------------code---------------------
GameCardSkeleton
-------------------code---------------------
<Card width="250px" borderRadius={10} overflow="hidden">
-------------------code---------------------

now we done in and commit our code coz it`s working next step we will fix the duplicattion issus
"Show Loading skeleton"

*** 16-_Refactor-_Removing_Duplicated_Styles ***

to remove the duplicattion styles from the previous lesson we should create  
another component that going to be the container of all the cards 
then we will apply the styles (duplicated styles) to our component

- so we create a component we called GameCardContainer.tsx 
- in this component we will return a Box component (from ChakaraUI)  and give the common styles 
from GameCard and GameCardSkeleton components

with that we single place where we defined the the styled of card 
-------------------code---------------------
const GameCardContainer = () => {
  return <Box width="250px" borderRadius={10} overflow="hidden"></Box>;
};
-------------------code---------------------

now we remove the styles remove form GameCard and GameCardSkeleton

- next we should pass GameCard and GameCardSkeleton as child component to GameCardContainer
to do that we define an interface of children and called it inside the Box component
-------------------code---------------------
interface Props {
  children: ReactNode;
}

const GameCardContainer = ({ children }: Props) => {
  return (
    <Box width="250px" borderRadius={10} overflow="hidden">
      {children}
    </Box>
  );
};
-------------------code---------------------

- finally in the GameGrid where we call GameCard and GameCardSkeleton we grap them with GameCardContainer


-------------------code---------------------
{isLoading &&
  skeletons.map((skeleton) => (
    <GameCardContainer>
      <GameCardSkeleton key={skeleton} />
    </GameCardContainer>
  ))}
{games.map((game) => (
  <GameCardContainer>
    <GameCard key={game.id} game={game} />
  </GameCardContainer>
))}
-------------------code---------------------

now we commit our code 
"Refactor: remove duplicated styles"

*** 17-_Fetching_the_Genres ***
now we will start to build the aside panal to display the Game genre when the user 
select a specific genre the games will be filter by that genre 

we will build it step by step the first step is to fetch the genre 

- we create a component we called GenreList.tsx

- now to fetch the genre we create a custom hood that similar to the one that we created to fetch the games
in the hooks folder we create another hook we called useGenres.ts

simply we create constant called useGenres and export by default
-------------------code---------------------
const useGenres = () => {};

export default useGenres;
-------------------code---------------------
now this hooks will be similar to useGames so we copy the function code from useGames
and paste it 

now in this case we will have duplication coz these two hooks will be similar
so for now we will make it work then we will remove the duplications

now to fix the error in our copied code 
first we import hooks like useState then instead of Game[] interface we create Genre interface

so first to create the interface of Genre we go back to the documentation of rog
to see the responese of Genre request

https://api.rawg.io/docs/

we go to the endpoint genres 
in the Responeses section we see 
count
next
previous
result 
and similar to the games endpoint

in the result we can see all the properties

for the simplicity we use only id and name 

-------------------code---------------------
 interface Genre {
  id: number;
  name: string;
}
-------------------code---------------------

now we change the name of the interface to Genre[] then we fix the variables name 
by using rename shortcut shift+2 (custome)  (f2 for fow windows) we rename the all the variable faster

-------------------code---------------------
const [genres, setGanres] = useState<Genre[]>([]);
-------------------code---------------------

- next we define FetchGemresResponse interface and the same as useGames we add count and result 
-------------------code---------------------
interface FetchGemresResponse {
  count: number;
  results: Genre[];
}
-------------------code---------------------

and finally change the endpoint to genres
-------------------code---------------------
.get<FetchGemresResponse>("/genres", { signal: contoller.signal })
-------------------code---------------------

- PS we rename by using f2 vsCode by default changed this return 
from 
-------------------code---------------------
return { games , error, isLoading };
-------------------code---------------------

to
-------------------code---------------------
return { games: genres, error, isLoading };
-------------------code---------------------

so we remove the extra games coz we don`t need it 
-------------------code---------------------
return { genres, error, isLoading };
-------------------code---------------------

now to test our hook in our GenreList we call our useGenre hook then we render like
list 

-------------------code---------------------
const GenreList = () => {
  const { genres } = useGenres();
  return (
    <>
      <ul>
        {genres.map((genre) => (
          <li key={genre.id}>{genre.name}</li>
        ))}
      </ul>
    </>
  );
};
-------------------code---------------------

finally we add GenreList component to App.tsx in the Aside section

now we will commit our code and next we will refactor our code 
"Fetch the genres"

*** 18-_Creating_a_Generic_Data_Fetching_Hook ***

our hooks until this point are identical, to avoid the duplication we will create a Generic Data Fetching Hook 
now in our hooks folder we create useData.ts

- now we take all the code from useGenre and copied inside the useData.ts

- now we are going to modify this code line by line
everywhere that we have reference to genre we should remove that reference or make it generic

- so first we delete the Genre interface

- interface FetchGemresResponse we will come to it later coz fetching the responese
is similar in each Games hook and Genre hook 

PS: use f2 (shift + 2 my custom shortcut) to rename the rename all the variables at same time in the file
- next we should rename the function of useGenre to useData 

- rename the genres and setGanres to data and setData

- change the Genre[] with generic type parameter <T>
-------------------code---------------------
const useData = () => {
  const [data, setData] = useState<Genre[]>([]);

  ... }
-------------------code---------------------

- error and loading no need to change coz we need to use it both the custom hooks 

- now we when get the data we don`t want to use FetchGemresResponse interface instead we need a generic interface
so we rename it to FetchResponse and change the results type to T[] and that means we have to generic type parameter <T>
to the interface
-------------------code---------------------
interface FetchResponse<T> {
  count: number;
  results: T[];
}
-------------------code---------------------

- now we have a compilation error says:
"Generic type 'FetchResponse<T>' requires 1 type argument(s)."

coz we defined FetchResponse as interface take <T> as parameter so we need add parameter to it
-------------------code---------------------
.get<FetchResponse<T>>("/genres", { signal: contoller.signal })
-------------------code---------------------

so this <T> is the same <T> that we had passed to our entire hook 
-------------------code---------------------
const useData = <T>() =>
-------------------code---------------------

- next we need to get rid of the genre endpoint "/genres" to do that we give the hook
a parameter called endpoint with type string and use it when we get the data 
-------------------code---------------------
const useData = <T>(endpoint: string)


.get<FetchResponse<T>>(endpoint, { signal: contoller.signal })
-------------------code---------------------

- the final part that we don`t want to return genres but only data 
-------------------code---------------------
return { data, error, isLoading };
-------------------code---------------------


- now we done with this hook and let test it in the Genre custom hook

so in GenreList 
instead of calling useGenres we call useData and pass Genre as generic type parameter and "/genres" as endpoint parameter
-------------------code---------------------
const { genres } = useData<Genre>("/genres");
-------------------code---------------------

we got error coz we need to export Genre interface from Genre hook 
then we need to rename genres to data (vs code has sometimes problem const { genres: data } = useData<Genre>("/genres");)
so we fix it manually
-------------------code---------------------
const { data } = useData<Genre>("/genres");
-------------------code---------------------

- now we test our code until point 


- our code works finally but we have refactor problem 
our we need to pass "/genres" as endpoint inside GenreList but early we said we need to split backend code from the frontend 
to fix that we got to Genre.ts 

- we don`t need FetchGemresResponse so we remove it

- remove all the code from inside the useGenre coz we already imploment it inside Data hook 
and instead we pass Genre as  generic type parameter and "/genres" as endpoint parameter
-------------------code---------------------
const useGenres = () => useData<Genre>("/genres");
-------------------code---------------------

- with that we hide the backend detail inside the useGenres hook 

- we remove all unused import statement using cmd+. 

- now in the GenreList component we replace useData with useGenre
-------------------code---------------------
const { data } = useGenres();
-------------------code---------------------

- finally we removed all unused import statement using cmd+.

- and test if our application is still working 

- with same way we modify the games hook so we copy all the code from the useGenre hook and change the interface and hook name 


PS:
in GameGrid when we call the useGames we should rename games with data 
-------------------code---------------------
const { data, error, isLoading } = useGames();
-------------------code---------------------

- now we test our code and commit our changes 
"Creating a generic data function hook"

*** 19- Displaying the Genres ***
now we are going to show the genres for each genre we have an image and label 

now to get the image we got the Network tap we go to genre endpoint and we can see
property called image_background and we need to add to genre interface 

- by typing cmd + t we move to genre interface and add image_background
-------------------code---------------------
export interface Genre {
  id: number;
  name: string;
  image_background: string;
}
-------------------code---------------------

- then in GenreList component we reolace ul with List component from ChakaraUI to render a list item
without bullet points and replace at the same time li with ListItem 
-------------------code---------------------
<List>
  {data.map((genre) => (
    <ListItem key={genre.id}>{genre.name}</ListItem>
  ))}
</List>
-------------------code---------------------

- next we need to render the name and image of the genre horizontal so we add inside the ListItem 
component a HStack element 
-------------------code---------------------
<List>
  {data.map((genre) => (
    <ListItem key={genre.id}>
      <HStack>
        
      </HStack>
    </ListItem>
  ))}
</List>
-------------------code---------------------

- now inside the HStach we add Image Component of the ChakaraUI and it should be small so we 
set the boxSize to 32px and we want to apply radius at the same time so we set the borderRadius to 8 px
and finally we set the src to the image (but same as image we don`t want to render the full size of the image 
so we use the getCroppedImageUrl method that we created to take the small sized image)

-------------------code---------------------
<HStack>
  <Image
    boxSize="32px"
    borderRadius={8}
    src={getCroppedImageUrl(genre.image_background)}
  />
</HStack>
-------------------code---------------------

- after the image we add a Text component to render the genre name 
-------------------code---------------------
<HStack>
  <Image
    boxSize="32px"
    borderRadius={8}
    src={getCroppedImageUrl(genre.image_background)}
  />
  <Text>{genre.name}</Text>
</HStack>
-------------------code---------------------

- now we check if our rendering done successfully 

- now we need to improve our few things

- first we need to apply a vertical padding to each list item 
so they`re not too close to each other 
-------------------code---------------------
<ListItem key={genre.id} paddingY="5px">
-------------------code---------------------

- next we want to increase the size of the font of the genere name
-------------------code---------------------
<Text fontSize="lg">{genre.name}</Text>
-------------------code---------------------

- our genere are so close to the edge of the screen so we will add a horizontal padding 
in this case is better to apply the padding to the aside layout of App.tsx so 
in future if we add another component other than List we have to remmber to add either to that component
-------------------code---------------------
<GridItem area={"aside"} paddingX="5px">
-------------------code---------------------

- next we want to apply a fixed width to the columns so if we have more read estate on the screen
our game grid stretchs and takes up the available space 
to define the width to our component we set the templateColumns to object coz we have two diffrent sernarios
where we have base(we have single columns) and lg(where we have multi columns) screen 
for base we will set the width to 1fr which means one fraction so our columns scratches and takes up
all the available space on lg devices we will have two columns one 200px and one 1fr
-------------------code---------------------
<Grid
  templateAreas={{
    base: `"nav" "main"`,
    lg: `"nav nav" "aside main"`,
  }}
  templateColumns={{
    base: "1fr",
    lg: "200px 1fr",
  }}
>
-------------------code---------------------


- finally to make our game take 100% of the screen we remove the fixed width from GameCardContainer
(by that we fix the skeleton layout either)
-------------------code---------------------
<Box borderRadius={10} overflow="hidden">
  {children}
</Box>
-------------------code---------------------

- now we can see the space between cards are too wide to fix that we go to GameGrid component and
reduce the space to 3 
-------------------code---------------------
<SimpleGrid
        columns={{ sm: 1, md: 2, lg: 3, xl: 5 }}
        padding="10px"
        spacing={3}
      >
-------------------code---------------------

now we check our layout in all devices 

and commit our code 
"Displaying the Genres"

*** 20-_Showing_a_Spinner ***
now we want to add a spinner while waiting to our genre data to fetch from the server 

- in our GenreList we grape isLoading from useGenres hook
-------------------code---------------------
const { data, isLoading } = useGenres();
-------------------code---------------------

- now we say if is loading we a want to return a spinner 
that is all what we want to do 
-------------------code---------------------
const { data, isLoading } = useGenres();

if (isLoading) return <Spinner />;
return (
  <></>
)
-------------------code---------------------

- now what if we had an error, we don`t want to throw too many diffrent errors on diffrent parts on the page
that way too much conforntint, so we want only to return null 
-------------------code---------------------
const { data, isLoading, error } = useGenres();

if (error) return null;

if (isLoading) return <Spinner />;

return (
  <></>
)
-------------------code---------------------

- now we simulate error by change the endpoint to "/genresX" and test our code 

now we commit our code 
"Show a spinner while fetching the genre"


*** 21-_Filtering_Games_by_Genre ***
we `re going to imploment filtering so when we press click on genre we only see the games that match
that genre 


- in GenreList component first we want to change the Text with genre.name to button to be able to 
click that genre set we set the variant to link to ou button looks like links 
-------------------code---------------------
<Button fontSize="lg" variant="link" >{genre.name}</Button>
-------------------code---------------------

- now we onClick event and for right now we will log the currect genre in the console 
-------------------code---------------------
<Button
  fontSize="lg"
  variant="link"
  onClick={() => console.log(genre)}
>
  {genre.name}
</Button>
-------------------code---------------------

- now when we open the console we test our click event we an error
"Warning: Each child in a list should have a unique "key" prop."
so before we contiune we shuold fix this Warning to do that in GameGrid component
we move the key properties form the child elements to the parent elements
-------------------code---------------------
<GameCardContainer key={skeleton}>
  <GameCardSkeleton />
</GameCardContainer>
-------------------code---------------------
and 
-------------------code---------------------
<GameCardContainer key={game.id}>
  <GameCard game={game} />
</GameCardContainer>
-------------------code---------------------

same error with PlatformIconList

so we fix it by add key with platform.id
-------------------code---------------------
{platforms.map((platform) => (
          <Icon key={platform.id} as={iconMap[platform.slug]} color="gray.500"></Icon>
        ))}
-------------------code---------------------


**************************************
PS when we don`t have id we can use the index as key
-------------------code---------------------
{platforms.map((platform, index) => (
          <Icon key={index} as={iconMap[platform.slug]} color="gray.500"></Icon>
        ))}
-------------------code---------------------
**************************************


- after cleaing our code wanings now we need to share the selected genre with the game grid

- so here we question how can we share the state with two components
to do that we should lift up to the closet parent component
so what is the parent of this two components 
it`s the App component 


- now in the App component we craete useState and set to null so initialilly no genre 
is selected we called selectedGenre 
-------------------code---------------------
const [selectedGenre, setSelectedGenre] = useState(null);
-------------------code---------------------

until this point we can`t set the selectedGenre to a diffrent value other than null coz TypeScript 
compiler doesn`t know that this varible can store Genre object so we need to type a generic type
argument 

we add null coz we want to apply select genre or null(nothing selected)
-------------------code---------------------
const [selectedGenre, setSelectedGenre] = useState<Genre | null>(null);
-------------------code---------------------

- now when we select genere the GenreList component should notify the App component so set the selectedGenre
remmber: the component that holds some state should be the one updating it 

- so we got to the GenreList component and Props with tha callback function 
-------------------code---------------------
interface Props {
  onSelectedGenre: (genre: Genre) => void;
}
-------------------code---------------------

- then we add the props 
-------------------code---------------------
const GenreList = ({ onSelectedGenre }: Props)
-------------------code---------------------

- finally instead of loging only the genre we pass the onSelectedGenre
-------------------code---------------------
<Button
  fontSize="lg"
  variant="link"
  onClick={() => onSelectedGenre(genre)}
>
  {genre.name}
</Button>
-------------------code---------------------

- now in App component we pass GenreList the onSelectedGenre property
-------------------code---------------------
<GenreList onSelectedGenre={(genre) => setSelectedGenre(genre)} />
-------------------code---------------------

- now let`s test out implomantaion until this point
in the Browser we select a Action genre for example 
access to Components of dev tool and press on App component and we should see the selected state


- next we need to pass this state to out game grid so it can be passed to the backend
while fetching the games so in GameGrid component 
we define selectedGenre that may can be Genre or null 
-------------------code---------------------
interface Props {
  selectedGenre: Genre | null;
}
-------------------code---------------------


then we add to props 
-------------------code---------------------
const GameGrid = ({ selectedGenre }: Props)
-------------------code---------------------

then we should add it to the game hook 
-------------------code---------------------
const { data, error, isLoading } = useGames(selectedGenre);
-------------------code---------------------

that means we should modify the useGame hook 
-------------------code---------------------
const useGames = (selectedGenre: Genre | null) => useData<Game>("/games");
-------------------code---------------------

we need to make another change in useGame hook we need to pass (selectedGenre: Genre | null) 
to our useData hook 
now our useData hook only take an endpoint but we need to make more flexible by give it 
"Axios request config object"
to give it Axios request config object
in this code the object that we passed as second argument ({signal: ....}) is what we call "Axios request config object"
-------------------code---------------------
apiClient
    .get<FetchResponse<T>>(endpoint, { signal: contoller.signal })
-------------------code---------------------
in this second argument we can pass data or qurey stirng parameter

- so we give our useData hook another paramter we called requestConfig 
and set it to the type of AxiosRequestConfig and we make it optional 
so we don`t always have to pass it 
-------------------code---------------------
const useData = <T>(endpoint: string, requestConfig?: AxiosRequestConfig) =>{

}
-------------------code---------------------

- now to filter our games depend on genre we should pass the genre as qurey string parameter

*********************************************************************************************************
What is Query string parameters:

Query string parameters are a way to pass information to a web server as part of a URL. 
They are commonly used in web development for sending data via HTTP GET requests.

Example 1: Simple Search Query
URL:
https://www.example.com/search?query=cats

Explanation:
This URL is querying the search endpoint with a parameter query having the value cats.


Query string parameters are a way to pass information to a web server as part of a URL. They are commonly used in web development for sending data via HTTP GET requests. Here are some examples to illustrate different scenarios:

Example 1: Simple Search Query
URL:

https://www.example.com/search?query=cats
Explanation:
This URL is querying the search endpoint with a parameter query having the value cats.

Example 2: Multiple Parameters
URL:
https://www.example.com/search?query=cats&sort=asc&page=2

Explanation:
This URL is querying the search endpoint with multiple parameters:

query with the value cats
sort with the value asc (ascending)
page with the value 2 (second page of results)

Example 3: Parameters with Special Characters
URL:

https://www.example.com/search?query=New+York&category=restaurants
Explanation:
In this URL:

query parameter has the value New York (space is encoded as + or %20)
category parameter has the value restaurants
Example 4: Date Range Filter
URL:

https://www.example.com/events?start_date=2023-01-01&end_date=2023-12-31
Explanation:
This URL filters events between January 1, 2023, and December 31, 2023, using the start_date and end_date parameters.

Example 5: Complex Parameters with Arrays
URL:

https://www.example.com/products?category=electronics&features[]=bluetooth&features[]=wifi
Explanation:
This URL is querying the products endpoint for electronics category products that have both bluetooth and wifi features.

Example 6: Authentication Token
URL:

https://www.example.com/user/profile?token=abc123
Explanation:
This URL uses a token parameter for authenticating the user accessing their profile.

Example 7: Locale and Language
URL:

https://www.example.com/content?locale=us&language=en
Explanation:
This URL sets the locale to us and the language to en (English).

Example 8: Pagination
URL:

https://www.example.com/articles?page=3&limit=10
Explanation:
This URL is querying the articles endpoint to get the third page of results with a limit of 10 articles per page.
*********************************************************************************************************

- so when we should pass qurey parameter that depends of the api
if it support the query parameter string and in our API (it supported)
we can see the genre as query parameter
https://api.rawg.io/docs/#tag/games


- so inside the game hook we set the params(one of property of AxiosRequestConfig)
and coz genre could be bull here we use ?. optional chaining 
-------------------code---------------------
const useGames = (selectedGenre: Genre | null) =>
  useData<Game>("/games", { params: { genres: selectedGenre?.id } });
-------------------code---------------------

- now we back to our useData hook and ...requestConfig to pass to be able
to add any additional properties
-------------------code---------------------
apiClient
      .get<FetchResponse<T>>(endpoint, {
        signal: contoller.signal,
        ...requestConfig,
      })
-------------------code---------------------

- now we test our application until this point 

- when we select some genre nothing changing so let`s check our Network tab to see what we sending 
to our server 
we can see that when we select a genre we don`t send a request to the server why that happing?

in useData when  we use useEffect we pass empty brackets([]) as second argument
empty brackets in useEffect that`s means we want to fetch the data only the first time a component
is rendrered.

to to solve this issue we should pass an array of dependencies as second argument of useEffect hook 
so when the selector genre changes we send another request to get the games that match the selected genre
to do that 
we add deps as thid parameter which is going to be an array of dependencies, now at this point we don`t 
know the type of that dependencies, so any array 
-------------------code---------------------
const useData = <T>(
  endpoint: string,
  requestConfig?: AxiosRequestConfig,
  deps: any[]
)
-------------------code---------------------

we have compilation error coz we set deps parameter which not optional after the requestConfig option parameter
but in our case we will we set the deps as optional as well so no need to move it 
-------------------code---------------------
const useData = <T>(
  endpoint: string,
  requestConfig?: AxiosRequestConfig,
  deps?: any[]
)
-------------------code---------------------

- next we pass ...deps as second argument of useEffect hook 
-------------------code---------------------
[...deps];
-------------------code---------------------

- but we have compilation error says 
Type 'any[] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator.

coz we deps as optional it could be undefined, and we can`t ... for undefined object 
to fix that 
-------------------code---------------------
deps ? [...deps] : []
-------------------code---------------------

- next we should specify the genre when calling the data hook and pass the deps array argument
-------------------code---------------------
const useGames = (selectedGenre: Genre | null) =>
  useData<Game>("/games", { params: { genres: selectedGenre?.id } }, [
    selectedGenre?.id,
  ]);
-------------------code---------------------

- now the last step we back to App components and pass the selected genre to GameGrid component
-------------------code---------------------
<GridItem area={"main"}>
  <GameGrid selectedGenre={selectedGenre} />
</GridItem>
-------------------code---------------------

TORECAP:
 
- in GenreList componentwe added a new  props called onSelectGenre 
to notify the consumer of the component that the genre has bees slected 

- the parens of GenreList  is App component so insideit we notify and set the selector Genre
this cause the app component to rerender

- so in the next render we will pass the selector genre to the GameGrid  

- in our GameGrid we add a new props which is selectedGenre and inside the component we take the 
value of the slected genre and pass it to our game hook 

- now our game hook passes the selector genre as qurey string parameter to the data hook 

we commit our code 
"Filter games by genre"

*** 22-_Highlighting_the_Selected_Genre ***

we should have the app component pass the selected genre, to our GenreList.tsx.
and in GenreList where we render the button we`ll set the font weight dynamically.
so if yo`re rendreing the selected genre, we make the font bold. other wise we render it normal 


to to imploment it
in GenreList
- we add to Props selectedGenre
-------------------code---------------------
interface Props {
  onSelectedGenre: (genre: Genre) => void;
  selectedGenre: Genre | null;
}
-------------------code---------------------

- we pass as parameter
-------------------code---------------------
const GenreList = ({ selectedGenre, onSelectedGenre }: Props) => {}
-------------------code---------------------

- we pass the fontweight to button 
-------------------code---------------------
fontWeight={genre.id === selectedGenre?.id ? "bold" : "normal"}
-------------------code---------------------

- finally in the App component we we set the selectedGenre to selectedGenre
-------------------code---------------------
<GenreList
  selectedGenre={selectedGenre}
  onSelectedGenre={(genre) => setSelectedGenre(genre)}
/>
-------------------code---------------------

here we commit our code
"High light the selected genre"

*** 23-_Building_Platform_Selector ***
now we will just focus on rendreing this list and after we will imploment filtering

- we create a component called PlatformSelector
and inside we are going to return a Menu component of ChakaraUI and inside the Menu
Component we create MenuButton component as Button

-------------------code---------------------
<Menu>
  <MenuButton as={Button}>Platforms</MenuButton>
</Menu>
-------------------code---------------------

- we give the MenuButton rightIcon of BsChevronDown
-------------------code---------------------
<Menu>
  <MenuButton as={Button} rightIcon={<BsChevronDown></BsChevronDown>}>
    Platforms
  </MenuButton>
</Menu>
-------------------code---------------------

- right after the MenuButton we add MenuList 
and inside the MenuList we add right now 3 Menuitem 
-------------------code---------------------
<MenuList>
  <MenuItem>item1</MenuItem>
  <MenuItem>item2</MenuItem>
  <MenuItem>item3</MenuItem>
</MenuList>
-------------------code---------------------

and let`s test our application until this point 

- we go to App component and add out PlatformSelector above GameGrid
-------------------code---------------------
<GridItem area={"main"}>
  <PlatformSelector></PlatformSelector>
  <GameGrid selectedGenre={selectedGenre} />
</GridItem>
-------------------code---------------------

- next we need to render the items dynamically
to do that we need to use different endpoint on rock API

we go to https://api.rawg.io/docs/#tag/platforms
and press "Get a list of parent platforms."

we can see the endpoint 
GET /platforms/lists/parents

- so we need to create a custome hook to fetch the data from the endpoint

- in hooks folder we create a file called usePlatforms.ts
we copy the code from the useGenre and 
1- change the Genre to Platform
2- change the interface to match the platform 
3- change the endpoint url 
-------------------code---------------------
import useData from "./useData";

export interface Platforms {
  id: number;
  name: string;
  slug: string;
}

const usePlatforms = () => useData<Platforms>("/platforms/lists/parents");

export default usePlatforms;
-------------------code---------------------

- now we got PlatformSelector.tsx and use our new hook 
we get the data form the usePlatforms hook 
-------------------code---------------------
const { data } = usePlatforms();
-------------------code---------------------

then render it 
-------------------code---------------------
<MenuList>
  {data.map((platform) => (
    <MenuItem key={platform.id}>{platform.name}</MenuItem>
  ))}
</MenuList>
-------------------code---------------------

- now if we had error we don`t want to render too much error messages for each 
component so we will return null
-------------------code---------------------
if (error) return null;
-------------------code---------------------

- now we test our error by going to the usePlatforms hook and manipulate the endpoint url

now we commit our code 
"Build platform selector"

*** 24-_Filtering_Games_by_Platform  ***

we will use the same approch as genere

- in the App component we declear a state variable for keeping track 
of the selected platform changes.
we pass the selected platform to the game grid for filtering
-------------------code---------------------
const [selectedPlatform, setSelectedPlatform] = useState<Platform | null>(
    null
  );
-------------------code---------------------

- now when the user select a platform we should notify the App component
so we should go to the PlatformSelector.tsx and define a Props
-------------------code---------------------
interface Props {
  onSelectPlatform: (platform: Platform) => void;
}
-------------------code---------------------

- next we add as parameter
-------------------code---------------------
const PlatformSelector = ({ onSelectPlatform }: Props) => {}
-------------------code---------------------

- for handing the selection 
-------------------code---------------------
<MenuItem
  onClick={() => onSelectPlatform(platform)}
  key={platform.id}
>
  {platform.name}
</MenuItem>
-------------------code---------------------

with that we notified our App component

- next we go to App component and set this props 
-------------------code---------------------
<PlatformSelector
  onSelectPlatform={(platform) => setSelectedPlatform(platform)}
></PlatformSelector>
-------------------code---------------------

now let`s test our implomantaion until this point

now if we slected a platform nothing happens but we can see in the dev tool 
when we go to components that the status has changed so our plumbing is working

- now we need to pass this slector platform to teh GameGrid component

so in App component
-------------------code---------------------
<GameGrid
  selectedPlatform={selectedPlatform}
  selectedGenre={selectedGenre}
/>
-------------------code---------------------

- but we didn`t define the selectedPlatform in the GameGrid component yet so 
first we add to Props
-------------------code---------------------
interface Props {
  selectedGenre: Genre | null;
  selectedPlatform: Platform | null;
}
-------------------code---------------------

- then we add as parameter 
-------------------code---------------------
const GameGrid = ({ selectedGenre, selectedPlatform }: Props) => {}
-------------------code---------------------

- we should pass to the useGame hook 
-------------------code---------------------
const { data, error, isLoading } = useGames(selectedGenre, selectedPlatform);
-------------------code---------------------

- we modify the game hook to take platform as parameter and pass to the API using 
parameter object 
-------------------code---------------------
const useGames = (
  selectedGenre: Genre | null,
  selectedPlatform: Platform | null
) =>
  useData<Game>(
    "/games",
    {
      params: {
        genres: selectedGenre?.id,
        parent_platforms: selectedPlatform?.id,
      },
    },
    [selectedGenre?.id]
  );
-------------------code---------------------

- then we should add selectedPlatform as dependency so many changes are affecting refreshes the data
-------------------code---------------------
useData<Game>(
    "/games",
    {
      params: {
        genres: selectedGenre?.id,
        parent_platforms: selectedPlatform?.id,
      },
    },
    [selectedGenre?.id, selectedPlatform?.id]
  );
-------------------code---------------------

- but still is not clear which platform is selected so we should render the label of the
Platform dynamically

- in App component we add selectedPlatform to the PlatformSelector
-------------------code---------------------
<PlatformSelector
  selectedPlatform={selectedPlatform}
  onSelectPlatform={(platform) => setSelectedPlatform(platform)}
></PlatformSelector>
-------------------code---------------------


- then we add selectedPlatform as Props to PlatformSelector.tsx 
-------------------code---------------------
interface Props {
  selectedPlatform: Platform | null;
  onSelectPlatform: (platform: Platform) => void;
}
-------------------code---------------------

and add as parameter 
-------------------code---------------------
const PlatformSelector = ({ onSelectPlatform, selectedPlatform }: Props) => {}
-------------------code---------------------

and finally
instead of rendering Platforms
-------------------code---------------------
{selectedPlatform?.name || "Platforms"}
-------------------code---------------------

- now we test our code until this point (filtering the genre and the platform togather)
and we check our Network tab in dev tool to see if we send a correct request(has genre and platform parameters)
we commit our code
"Filter games by platforms"

*** 25-_Refactoring-_Extracting_a_Query_Object ***

it`s a refactoring time
Currentlyin App.tsx we`ve got two useState variable (selectedGenre and selectedPlatform)
but as we add more feature for filtering or sorting we will need to much useState 
which will make our code more ugly and hard repetitive

so what can we do here 
we should pack our related variable inisde what we call the "Query Object Pattern"
so we`ll create Query Object that contains all the information we need to query the games.
with this our code will be cleaner and easier to understand.


- first we define an interface called GameQuery with genre and platform (we didn`t called them selectGenre or selectPlatform)
coz it will be repetitive
-------------------code---------------------
interface GameQuery {
  genre: Genre | null;
  platform: Platform | null;
}
-------------------code---------------------

- next we remove selectedGenre and selectedPlatform useState and instead we create useState with type GameQuery
and we initialize to empty object not null coz we will only have a query object but the properties of this object
could be null 
-------------------code---------------------
useState<GameQuery>({});
-------------------code---------------------

but we have error :
Argument of type '{}' is not assignable to parameter of type 'GameQuery | (() => GameQuery)'

to get rid of this error we as keyword
-------------------code---------------------
useState<GameQuery>({} as GameQuery);
-------------------code---------------------

- we called gameQuery
-------------------code---------------------
const [gameQuery, setGameQuery] = useState<GameQuery>({} as GameQuery);
-------------------code---------------------

- now we have alot of error we have to fix them one by one 
-------------------code---------------------
<GridItem area={"aside"} paddingX="5px">
  <GenreList
    selectedGenre={gameQuery.genre}
    onSelectedGenre={(genre) => setGameQuery({ ...gameQuery, genre })}
  />
</GridItem>
-------------------code---------------------

and 
-------------------code---------------------
<PlatformSelector
  selectedPlatform={gameQuery.platform}
  onSelectPlatform={(platform) =>
    setGameQuery({ ...gameQuery, platform })
  }
></PlatformSelector>
-------------------code---------------------

and 
-------------------code---------------------
<GameGrid
  selectedPlatform={gameQuery.platform}
  selectedGenre={gameQuery.genre}
/>
-------------------code---------------------

- and now we need to use same technique in GameGrid.tsx 
insetad of passing a bunch of variable here 
-------------------code---------------------
const GameGrid = ({ selectedGenre, selectedPlatform }: Props) => {}
-------------------code---------------------

we should pass an object 
first we change the Props by adding gameQuery
-------------------code---------------------
interface Props {
  gameQurey: GameQurey;
  selectedGenre: Genre | null;
  selectedPlatform: Platform | null;
}
-------------------code---------------------

- we export form App.tsx 

- next we remove this ugly properties
-------------------code---------------------
selectedGenre: Genre | null;
selectedPlatform: Platform | null;
-------------------code---------------------

-  change GameGrid parameters to 
-------------------code---------------------
const GameGrid = ({ gameQurey }: Props) => {}
-------------------code---------------------

- now instead of passing multiple arguments to useGames we pass only one argument
-------------------code---------------------
 const { data, error, isLoading } = useGames(gameQurey);
-------------------code---------------------

- so we need to modify the parameter of useGames hook 
-------------------code---------------------
const useGames = (gameQuery: GameQuery)
-------------------code---------------------

- and fix the error code 
and instead of passing the id of each object as dependencies we can pass all the object
-------------------code---------------------
const useGames = (gameQuery: GameQuery) =>
  useData<Game>(
    "/games",
    {
      params: {
        genres: gameQuery.genre?.id,
        parent_platforms: gameQuery.platform?.id,
      },
    },
    [gameQuery]
  );
-------------------code---------------------

- finaly we have in App.tsx error coz we changed the properties of GameGrid so we fix it 
-------------------code---------------------
<GameGrid gameQurey={gameQuery} />
-------------------code---------------------

now we test our code if our platform and genre work fine 
then we commit our code 
"Refactor: Extract a Query Object"



*** 26-_Building_Sort_Selector ***
we will add another dropdown list next to platform to sort the games 
now we will only render the sort component later we will do the actual sorting

- first we create a new component SortSelector 
this component will be too much similar to our Platform component
to save time we will copy the code (return statement) from Platform component
and for label we will render somthing static like "Order by: Relevance"
and where we map the platform we render MenuItem*6
-------------------code---------------------
<Menu>
  <MenuButton as={Button} rightIcon={<BsChevronDown></BsChevronDown>}>
    Order by: Relevance
  </MenuButton>
  <MenuList>
    <MenuItem>Relevance</MenuItem>
    <MenuItem>Date added</MenuItem>
    <MenuItem>Name</MenuItem>
    <MenuItem>Release date</MenuItem>
    <MenuItem>Popularity</MenuItem>
    <MenuItem>Average rating</MenuItem>
  </MenuList>
</Menu>
-------------------code---------------------

- next we render it in App component
-------------------code---------------------
<GridItem area={"main"}>
  <PlatformSelector
    selectedPlatform={gameQuery.platform}
    onSelectPlatform={(platform) =>
      setGameQuery({ ...gameQuery, platform })
    }
  ></PlatformSelector>
  <SortSelector></SortSelector>
  <GameGrid gameQurey={gameQuery} />
</GridItem>
-------------------code---------------------

- we check our code it`s work but need to add space between PlatformSelector and SortSelector
to do that we should wrap PlatformSelector and SortSelector in HStack component and apply spacing of 5
-------------------code---------------------
<HStack spacing={5}>
  <PlatformSelector
    selectedPlatform={gameQuery.platform}
    onSelectPlatform={(platform) =>
      setGameQuery({ ...gameQuery, platform })
    }
  ></PlatformSelector>
  <SortSelector></SortSelector>
</HStack>
-------------------code---------------------

now our platform menu is not lined up with the first card so we need to apply left padding to line them  
-------------------code---------------------
<HStack spacing={5} paddingLeft={2}>
-------------------code---------------------

now our card is too close the card so we need seprate them by adding bottom margin 

now we commit our code
"Build Sort Selector"

*** 27-_Sorting_Games ***
to sort the game we will take the same approch as filtering

so when the user select the sort order the SortSelector component will notify App component
and then the app component will pass the new sort order to the game grid.

- for sorting the data we will look at the documentation of the rog 
in Get a list of games.
we can see the "QUERY PARAMETER" inside we can see ordering query parameter
we can set it as it writin to name, released and so on 
and if we want for the reverse sort order we can use "-" before the sort order as the example
-------------------code---------------------
ordering	 string
           Available fields: name, released, added, created, updated, rating, metacritic.
          You can reverse the sort order adding a hyphen, for example: -released.
-------------------code---------------------


- now in SortSelector.tsx insetad of apply onClick to each Menuitem 
-------------------code---------------------
<MenuList>
  <MenuItem onClick{}>Relevance</MenuItem>
  <MenuItem onClick{}>Date added</MenuItem>
  <MenuItem onClick{}>Name</MenuItem>
  <MenuItem onClick{}>Release date</MenuItem>
  <MenuItem onClick{}>Popularity</MenuItem>
  <MenuItem onClick{}>Average rating</MenuItem>
</MenuList>
-------------------code---------------------

it`s better to store all MenuItem(sort order) valuse inside  an array and map each item of that array to MenuItem

- so on the top we create array of sort order 
this array containes objects each object has value (the one we want to send it the backend) and label (to show to UI)
-------------------code---------------------
const sortOrders = [
    { value: "", label: "" },
    { value: "", label: "" },
    { value: "", label: "" },
    { value: "", label: "" },
    { value: "", label: "" },
    { value: "", label: "" },
  ];
-------------------code---------------------

- now we add each value of MenuItem inside the label 
-------------------code---------------------
const sortOrders = [
    { value: "", label: "Relevance" },
    { value: "", label: "Date added" },
    { value: "", label: "Name" },
    { value: "", label: "Release date" },
    { value: "", label: "Popularity" },
    { value: "", label: "Average rating" },
  ];
-------------------code---------------------

- now for 
Relevance:
 the value will be empty coz we don`t want to send anything to server (default value)

Date added:
value will be added but we want to show the newest game first so we will add hyphen before -added

Name:
value will be name

Release date:
the value will be released with hyphon coz we want to show the newest one -released

Popularity:
the value will be -metacritic

Average rating:
the value will be -rating
-------------------code---------------------
const sortOrders = [
    { value: "", label: "Relevance" },
    { value: "-added", label: "Date added" },
    { value: "name", label: "Name" },
    { value: "-released", label: "Release date" },
    { value: "-metacritic", label: "Popularity" },
    { value: "-rating", label: "Average rating" },
  ];
-------------------code---------------------


- now we remove the 6 MenuItem and map sortOrders to each MenuItem
-------------------code---------------------
{sortOrders.map((order) => (
  <MenuItem key={order.value} value={order.value}>
    {order.label}
  </MenuItem>
))}
-------------------code---------------------

- next we add the onClick event to notify the App component (parent component)
first we add props 
-------------------code---------------------
interface Props {
  onSelectSortOrder: (sortOrder: string) => void;
}
-------------------code---------------------

next we give it as parameter to SortSelector 
-------------------code---------------------
const SortSelector = ({ onSelectSortOrder }: Props) => {}
-------------------code---------------------

finaly we set the value that we want to notify it to App component
-------------------code---------------------
<MenuItem
  onClick={() => onSelectSortOrder(order.value)}
  key={order.value}
  value={order.value}
>
  {order.label}
</MenuItem>
-------------------code---------------------

- now we should go to the App component

add the sort order to our query object
-------------------code---------------------
export interface GameQuery {
  genre: Genre | null;
  platform: Platform | null;
  sortOrder: string;
}
-------------------code---------------------

next pass the new game query object to our GameGrid
-------------------code---------------------
<SortSelector
  onSelectSortOrder={(sortOrder) =>
    setGameQuery({ ...gameQuery, sortOrder })
  }
></SortSelector>
-------------------code---------------------

now by adding the onSelectSortOrder to gameGrid it will causees the app component to be render (coz the status is changed)

now in the next render we will pass the new game query object to our GameGrid
inside GameGrid already we use useGame(gameQuery) so we don`t need to make any changes 
so we go to the useGame hook when calling the server we should add a new query parameter called ordering 
and coz we already encapsulating related value inside an object we don`t need to set the dependencies
-------------------code---------------------
useData<Game>(
    "/games",
    {
      params: {
        genres: gameQuery.genre?.id,
        parent_platforms: gameQuery.platform?.id,
        ordering: gameQuery.sortOrder,
      },
    },
    [gameQuery]
  );
-------------------code---------------------

- now let`s test our code 

- we can see our app is crashed 

in console we have this error:
TypeError: Cannot read properties of null (reading 'indexOf')

this happend in image URL on the line 4 if we click it we can see in the Browser
the error lcoation 
-------------------code---------------------
const index = url.indexOf(target) + target.length;
-------------------code---------------------

the reasong why coz some games doesn`t have images so we need to handle it 
but this issue is problem and different of what we are working on we will temproray fix 
and then we will fix it temproray by adding TODO: 
-------------------code---------------------
const getCroppedImageUrl = (url: string) => {
  // TODO: Cannot read properties of null (reading 'indexOf') for games without image
  if (!url) return "";
  const target = "media/";
  const index = url.indexOf(target) + target.length;
  return url.slice(0, index) + "crop/600/400/" + url.slice(index);
};
-------------------code---------------------


now we test or code and if we sorted by name we can see the games withuot image
we will fix this later 

now let`s check our request in dev tool to see if we are sending the right qurey parameter
we can see
-------------------code---------------------
key: --------
ordering: name
-------------------code---------------------

and now what if we select the platform then we slected the order 
-------------------code---------------------
parent_platforms: 3
ordering: -released
-------------------code---------------------
it`s still work finally

now one thing is missing is the dynamic currnet sorting label 
to render it we should have the app component pass the current sort order to SortSelector component
-------------------code---------------------
<SortSelector
  sortOrder={gameQuery.sortOrder}
  onSelectSortOrder={(sortOrder) =>
    setGameQuery({ ...gameQuery, sortOrder })
  }
-------------------code---------------------

and add this props to SortSelector
-------------------code---------------------
interface Props {
  onSelectSortOrder: (sortOrder: string) => void;
  sortOrder: string;
}
-------------------code---------------------

then add as parameter
-------------------code---------------------
const SortSelector = ({ onSelectSortOrder, sortOrder }: Props) => {}
-------------------code---------------------

now instead of rendering the relevance we should find the sort order with a given value of sortOrders array 
and sort is label 
-------------------code---------------------
const currentSortOrder = sortOrders.find(
    (order) => order.value === sortOrder
  );

-------------------code---------------------

finally we rendering it 
-------------------code---------------------
Order by: {currentSortOrder?.label || "Relevance"}
-------------------code---------------------

we commit our code 
"Sort the Games"

*** 28-_Handling_Games_without_an_Image ***

to handle the games without image we will use default placehoder from GameHub Resources.zip
and grap it inside the assets folder

we rename it to no-image-placeholder (make sure to webp)

- now in image-url.ts because the no-image-placeholder.webp is static asset that is going to deploy
in our application 
we can`t type path like ex
-------------------code---------------------
if (!url) return "../asset/imgae.webp";
-------------------code---------------------

instead we should import the image as module 
-------------------code---------------------
const getCroppedImageUrl = (url: string) => {
  // TODO: Cannot read properties of null (reading 'indexOf') for games without image
  if (!url) return noImage;
  const target = "media/";
  .... }
-------------------code---------------------

- finally we check our code and if it`s work we remove the TODO statement
-------------------code---------------------
import noImage from "../assets/no-image-placeholder.webp";

const getCroppedImageUrl = (url: string) => {
  if (!url) return noImage;
  const target = "media/";
  const index = url.indexOf(target) + target.length;
  return url.slice(0, index) + "crop/600/400/" + url.slice(index);
};
-------------------code---------------------

now our code run fine so we commit our code 
"Handle games with no images"

*** 29-_Fixing_the_Issue_with_Chakra_Menus ***

when we select an item from sorting or platform component we see an error in console 

for me i don`t see this error so i will skip this lesson 

*** 30-_Building_Search_Input ***
we will add search input to the navbar to search the games 

- first we create SearchInput.tsx

- we add inside Input component with placehoder and variant
-------------------code---------------------
<>
  <Input borderRadius={20} placeholder="Search games ..."></Input>
</>
-------------------code---------------------

- next we simply add this component to the NavBar.tsx next to Image component
-------------------code---------------------
<HStack justifyContent={"space-between"} padding="10px">
  <Image src={logo} boxSize="60px"></Image>
  <SearchInput />
  <ColorModeSwitch />
</HStack>
-------------------code---------------------

- now we can see that Dark Mode label is wrapped to fix it 
we go to ColorModeSwitch component and chnage add to Text whitSpace="nowrap" (nowrap is just a standerd CSS)
-------------------code---------------------
<Text whiteSpace="nowrap">Dark Mode</Text>
-------------------code---------------------

- now in NavBar component we set justifyContent="space-between" coz we only had two Components
now we already have three so no need for it we remove it 
-------------------code---------------------
<HStack padding="10px">
-------------------code---------------------

it will not make our UI better but it will make our code cleaner 

- now we want to add Icon to the SearchInput component
first we grap the Input componet with InputGroup component 
then we add the InputLeftElement component and set the children to BsSearch component
-------------------code---------------------
<>
  <InputGroup>
    <InputLeftElement children={<BsSearch />} />
    <Input borderRadius={20} placeholder="Search games ..."></Input>
  </InputGroup>
</>
-------------------code---------------------

now we test our code on multiple layout small and big 

we commit our code 
"Build search input"

*** 31-_Searching_Games ***
to imploment the searching we`ll use the same approach as before 
so when user type somthing in the search bar and press enter the SearchInput component
will notify the App component take this search text, store it in our qurey object
and pass it down to the GameGrid component exacly like platform and sort

- fisrt in the SearchInput component we will wrap all the elements inside form element
and we don`t need action instead we handle it manually using onSubmit
- we use preventDefault to prevent our form to post data to server 
-------------------code---------------------
<form
  onSubmit={(event) => {
    event.preventDefault();
  }}
>
  <InputGroup>
    <InputLeftElement children={<BsSearch />} />
    <Input borderRadius={20} placeholder="Search games ..."></Input>
  </InputGroup>
</form>
-------------------code---------------------

- next we want to access the input field value we can use useState or useRef but 
coz we have only one element it`s better to use useRef hook 

so we define ref element
-------------------code---------------------
const ref = useRef<HTMLInputElement>(null);
-------------------code---------------------

and then we associate this ref object with input components
-------------------code---------------------
<Input
  ref={ref}
  borderRadius={20}
  placeholder="Search games ..."
></Input>
-------------------code---------------------

- next we say if ref.currect is truthy for now we log the ref to check if it works 
-------------------code---------------------
<form
  onSubmit={(event) => {
    event.preventDefault();
    if (ref.current) console.log(ref.current.value);
  }}
>
-------------------code---------------------

now we check our code 
first we have layout issue coz form element doesn`t have the width of 100% 
we have two options 
option1 to add css dirctery 
-------------------code---------------------
<form
  style={{ width: "100%" }}
  onSubmit={(event) => {
    event.preventDefault();
    if (ref.current) console.log(ref.current.value);
  }}
>
-------------------code---------------------
but generaly speaking inline style are ugly and we should try to avoid them as much as possible

the better approach to add global rule in our stylesheet  
so we go to index.css and give all the form the width of 100% 
-------------------code---------------------
form {
  width: 100%;
}
-------------------code---------------------

- now we solved our layout issue and test the ref of the search input 
we can see if we type anything in the search input and press enter we can see it in the console 

so we need to take the value of search input and pass it to App component

- to pass to App component in SearchInput.tsx we add Props we will add function
onSearch that take searchText and return void
-------------------code---------------------
interface Props {
  onSearch: (searchText: string) => void;
}
-------------------code---------------------

next we add as paramter 
-------------------code---------------------
const SearchInput = ({ onSearch }: Props) => {

}
-------------------code---------------------

- and finally we change the log on console with onSearch method 
-------------------code---------------------
onSubmit={(event) => {
        event.preventDefault();
        if (ref.current) onSearch(ref.current.value);
      }}
-------------------code---------------------

- now we go to the App component
first we should add the search to our query object
-------------------code---------------------
export interface GameQuery {
  genre: Genre | null;
  platform: Platform | null;
  sortOrder: string;
  searchText: string;
}
-------------------code---------------------

now we can`t pass the searchText to Navbar coz we should pass it to InputSreach and InputSreach we called inside the 
NavBar 
we can`t pass a props to Navbar then pass it InputSreach coz it will make our code hard to maintaine in the future 
but now we will do it in this way then we will fix in the next part 

to save time we copy the interface from the SearchInput.tsx to NavBar.tsx
-------------------code---------------------
interface Props {
  onSearch: (searchText: string) => void;
}
-------------------code---------------------

pass it as parameter
-------------------code---------------------
const NavBar = ({ onSearch }: Props) => {}
-------------------code---------------------

then pass it to SearchInput
-------------------code---------------------
<SearchInput onSearch={onSearch} />
-------------------code---------------------

no we go back to App component and pass it the same as platform and sort game 
-------------------code---------------------
<GridItem area={"nav"}>
  <NavBar
    onSearch={(searchText) =>
      setGameQuery({ ...gameQuery, searchText })
    }
  />
</GridItem>
-------------------code---------------------

- now we will test out state if the value is the same as search input before sending it to server
we add "grand" to serach input and check in dev tool Components => App if the hooks state has serachText with grand 
-------------------code---------------------
State : {searchText: "dsadasd"}
searchText : "dsadasd"
-------------------code---------------------

- now we check it and saw it`s work fine then in useGames we pass it to backend
-------------------code---------------------
const useGames = (gameQuery: GameQuery) =>
  useData<Game>(
    "/games",
    {
      params: {
        genres: gameQuery.genre?.id,
        parent_platforms: gameQuery.platform?.id,
        ordering: gameQuery.sortOrder,
        search: gameQuery.searchText,
      },
    },
    [gameQuery]
  );
-------------------code---------------------


- now we check our code and it works and we commit our code 
"imploment Search"

*** 32-_Adding_a_Dynamic_Heading ***
next we will add a dynamic Header above the Platform and SortSelector components changes based on currunt
filter

ex: if we select Action from Genre  we will have "Action Games" and if we select Xbox from platform 
we will see "Xbox Action Games"

- we will create new component called GameHeading.tsx and we can return h1 element
but because we using ChakaraUI in all our project it`s better to use ChakaraUI components as much as possible
so we will use Heading component from ChakaraUI
-------------------code---------------------
<>
  <Heading as="h1"></Heading>
</>
-------------------code---------------------

- now to render the heading dynamically we should receive the game query object as a Props in GameHeading.tsx 
so let`s define the Props 
-------------------code---------------------
interface Props {
  gameQuery: GameQuery;
}
-------------------code---------------------

then we add as parameter
-------------------code---------------------
const GameHeading = ({ gameQuery }: Props) => {}
-------------------code---------------------

- so what the logic we want to render 
1- we want to render "Games" 
2- if the user select a genre we want to render genre name + Games ex: "Action Games" 
3- if the user select a platform we should render platform name + Games "Xbox Games" 
4- if the user select both genre and platform we want to show genre name + platform name + Games "Xbox Action Games"

to do that we define a constant of that logic and render it
-------------------code---------------------
const heading = `${gameQuery?.platform?.name} ${gameQuery.genre?.name} Games`;

  return (
    <>
      <Heading as="h1">{heading}</Heading>
    </>
  );
-------------------code---------------------

next we go the App component and render GameHeading before HStack component
-------------------code---------------------
<GameHeading gameQuery={gameQuery} />
-------------------code---------------------

now we test our code we can see we have 
"undefined undefined Games"

to fix that we render empty string if the value not exist 
-------------------code---------------------
const heading = `${gameQuery?.platform?.name || ""} 
  ${gameQuery.genre?.name || ""}
   Games`;
-------------------code---------------------

- now we test our code 
it`s work fine but we need to add a vertical margin coz our GameHeading is too much near to our SortSelector and PlatformSelector components
and we can also make our fon bigger 
-------------------code---------------------
<>
  <Heading as="h1" marginY={5} fontSize="5xl">
    {heading}
  </Heading>
</>
-------------------code---------------------

now we have issue that our GameHeading is not a line with our Sorts component coz we already pass paddingLeft={2}
to HStack now to fix we have two options 
1- add paddingLeft={2} to GameHeading either but that will make our code repetitive
and in future if add another component we have to remmber to paddingLeft={2} to it
2- better approach to wrap HStack and GameHeading inisde A Box and give a paddingLeft={2}

-------------------code---------------------
<Box paddingLeft={2}>
  <GameHeading gameQuery={gameQuery} />
  <HStack spacing={5} marginBottom={5}>
    <PlatformSelector
      selectedPlatform={gameQuery.platform}
      onSelectPlatform={(platform) =>
        setGameQuery({ ...gameQuery, platform })
      }
    ></PlatformSelector>
    <SortSelector
      sortOrder={gameQuery.sortOrder}
      onSelectSortOrder={(sortOrder) =>
        setGameQuery({ ...gameQuery, sortOrder })
      }
    ></SortSelector>
  </HStack>
</Box>
-------------------code---------------------

now our code looks beautiful and aligind 

now we commit our code 
"Add a dynamic page heading"

*** 33-_Cleaning_Up_the_Genres ***
there some few things that we want to improve in the look for example 
in genre we have 
"Massively Multiplayer" the text is too sticked togather and overlapping the image
this because we are using button and buttons by default don`t wrap text

how to fix it in GenreList.tsx we set the whiteSpace of the Button to normal (nowrap is the default value)
-------------------code---------------------
<Button
  whiteSpace="normal"
  fontSize="lg"
  fontWeight={genre.id === selectedGenre?.id ? "bold" : "normal"}
  variant="link"
  onClick={() => onSelectedGenre(genre)}
>
  {genre.name}
</Button>
-------------------code---------------------

but the text is currently center aligind, so we should make it left aligind, so it aligins with other 
genres 
-------------------code---------------------
<Button
  whiteSpace="normal"
  textAlign="left"
  fontSize="lg"
  fontWeight={genre.id === selectedGenre?.id ? "bold" : "normal"}
  variant="link"
  onClick={() => onSelectedGenre(genre)}
>
  {genre.name}
</Button>
-------------------code---------------------

- the next issue is we need to address involves our images, if we pay close attention we can see 
aspect ratio of these images is distorted because be getting images that 600 by 400
but we displaying them 32 by 32 boxes with objectFit="cover" the image will scaled to fit the container
while preserving it aspect ratio

-------------------code---------------------
<Image
  boxSize="32px"
  objectFit="cover"
  borderRadius={8}
  src={getCroppedImageUrl(genre.image_background)}
/>
-------------------code---------------------

- finaly we add Heading to our component says Genre
coz the heading is large we make it smaller and give it space between genres and the heading
-------------------code---------------------
<Heading fontSize="2xl" marginBottom={3}>
  Genres
</Heading>
-------------------code---------------------

now we commit our code 
"clean up the Genres"

*** 34-_Cleaning_Up_the_Game_Cards  ***

now we will clean our GameCards.tsx first we want to move the icons and metacritic a bove the name 
-------------------code---------------------
<HStack justifyContent="space-between">
  <PlatformIconList
    platforms={game.parent_platforms.map((p) => p.platform)}
  />
  <CriticScore score={game.metacritic} />
</HStack>
<Heading fontSize="2xl">{game.name}</Heading>
-------------------code---------------------

- but the HStack is close to our Heading so we will give it a button margin 
-------------------code---------------------
<HStack justifyContent="space-between" marginBottom={3}>
  <PlatformIconList
    platforms={game.parent_platforms.map((p) => p.platform)}
  />
  <CriticScore score={game.metacritic} />
</HStack>
-------------------code---------------------

- the next thing we want to improve is the spacing between the cards 
currently it`s too close to each other so in GameGrid.tsx 
we change the space to 6
-------------------code---------------------
<SimpleGrid
  columns={{ sm: 1, md: 2, lg: 3, xl: 5 }}
  padding="10px"
  spacing={6}
>
-------------------code---------------------

- now having 5 cards on larg screen is too much so we will do it 4
-------------------code---------------------
<SimpleGrid
        columns={{ sm: 1, md: 2, lg: 3, xl: 4 }}
        padding="10px"
        spacing={6}
      >
-------------------code---------------------

now we commit our code 
"clean up the Game card"

*** 35-_Adding_Emojis ***

now we will add Emojis to our project 
- first in useGames.ts we add to the interface rating_top
-------------------code---------------------
export interface Game {
  id: number;
  name: string;
  background_image: string;
  parent_platforms: { platform: Platform }[];
  metacritic: number;
  rating_top: number;
}
-------------------code---------------------

PS: in our API we have rating_top and rating the difference is between these two properties
is rating is a floating point number, while rating_top is a whole number 

- next we grap three images from GameHub Resources.zip to our assets

1-bulls-eye.webp
2-meh.webp
3-thups-up.webp

- next we create new component called Emoji.tsx
inside it we shoukd receive game rating_top as Props
-------------------code---------------------
interface Props {
  rating: number;
}

const Emoji = ({ rating }: Props) => {

}
-------------------code---------------------

- now if rating is less than 3 we are not going to render anything
-------------------code---------------------
const Emoji = ({ rating }: Props) => {
  if (rating < 3) return null;

  return <div>Emoji</div>;
};
-------------------code---------------------

- next depend on rating we want to show different emoji but we will are not going to use 
nasting if statement (remmber nasting if statement is ugly ) 
instead we are going to use map function

so to do that first we import the images 
-------------------code---------------------
import bullsEye from "../assets/bulls-eye.webp";
import thumpsUp from "../assets/thumbs-up.webp";
import meh from "../assets/meh.webp";
-------------------code---------------------


now each image has src and alt so we create emojiMap constant and map the number of rating to that alt and src 
-------------------code---------------------
const emojiMap = {
    3: { src: meh, alt: "meh" },
    4: { src: thumpsUp, alt: "recommended" },
    5: { src: bullsEye, alt: "exceptional" },
  };
-------------------code---------------------

- next we render Image of chakaraUI 
-------------------code---------------------
return (
    <>
      <Image {...emojiMap[rating]} />
    </>
  );
-------------------code---------------------

- we have type error coz we have to use index signature 
-------------------code---------------------
const emojiMap: { [key: number]: ImageProps } = {
    3: { src: meh, alt: "meh" },
    4: { src: thumpsUp, alt: "recommended" },
    5: { src: bullsEye, alt: "exceptional" },
  };
-------------------code---------------------

PS: import image from ChakraUI
-------------------code---------------------
import { ImageProps, Image } from "@chakra-ui/react";
-------------------code---------------------

- finally we set the boxSize to 25px 
-------------------code---------------------
<>
  <Image {...emojiMap[rating]} boxSize="25px" />
</>
-------------------code---------------------

- now we add to GameCard.tsx
-------------------code---------------------
<Heading fontSize="2xl">
  {game.name} <Emoji rating={game.rating_top} />
</Heading>
-------------------code---------------------

- now we test our code we can see bullsEye is not the same as thumpsUp so we should 
handle the size either 
-------------------code---------------------
const emojiMap: { [key: number]: ImageProps } = {
  3: { src: meh, alt: "meh", boxSize: "25px" },
  4: { src: thumpsUp, alt: "recommended", boxSize: "25px" },
  5: { src: bullsEye, alt: "exceptional", boxSize: "35px" },
};
-------------------code---------------------

now we emojis is code but the Emoji is too close o our haeading so we give it marginTop of 1
-------------------code---------------------
 <Image {...emojiMap[rating]} marginTop={1} />
-------------------code---------------------

now we commit our code 
"Add emoji"

*** 36-_Shipping_Static_Data ***

in the currect implomantaion we show a spinner while we fetch the genere 
and skeletons while we fetch the games.
so we`re dynamically loading to different parts of the page and showing loading indicators.
now whike this isn`t necessarily a bad thing, overusing this technique can negatively impact 
the user expression. it makes their eyes dart around the page.

so as cool idea to improve things:
we can ship the list of generes with our application. since the list of genres hardly 
ever chnages we can treat the genres as static data and included with our app
with that we don`t need to make extra request to our backend and the data will be available right away 
so no need to wait and show a spinner 

- now to do that we go to the deve tool and to to the request that have the Genres
and click on Preview and right click on result and copy the values 

- next in our src folder we create a folder called a data inside it we create a file called 
genres.ts and inside we type export default then paste the values 
-------------------code---------------------
export default [
  {
    id: 4,
    name: "Action",
    slug: "action",
    games_count: 180931,
    image_background:
      "https://media.rawg.io/media/games/f87/f87457e8347484033cb34cde6101d08d.jpg",
    games: [
      {
        id: 3498,
        slug: "grand-theft-auto-v",
        name: "Grand Theft Auto V",
        added: 21015,
      },
      ....
      ...
    ]}]
-------------------code---------------------

with that we including satic data in our application we don`t have to load them from the server 

next we go to the useGenres.ts  and instead of using useData we return object

-------------------code---------------------
const useGenres = () => ({ data: null, isLoading: false, error: null });
-------------------code---------------------

coz we want to minimize the impact of these changes on the consumers 
of useGenres hook. (we used the same return statements of useData)
ex: 
in GenreList when using useGenres we use { data, isLoading, error } properties
so we want the changes that we apply in the useGenres.ts to impact the components 
where we useed it 
-------------------code---------------------
const { data, isLoading, error } = useGenres();
-------------------code---------------------


- next we set the data property to genres that we stored in genres module 
first we import genres module then we set the data to that genres 
-------------------code---------------------
import genres from "../data/genres";



const useGenres = () => ({ data: genres, isLoading: false, error: null });
-------------------code---------------------

- now we test our code we can see our generes available right away without spinner 
in another word without connecting to server


now in our GenreList we can remove rendering the loading spinner or even the error 
but it`s better to keep them coz in future if we changed our mind and wanted to fetch the data from the server

-------------------code---------------------
if (error) return null;

if (isLoading) return <Spinner />;
-------------------code---------------------

PS: we can use the same technique with platforms too (we will make it as additional exercise)

now we commit our code 
"ship genres with the app"


*** 37-_Customizing_the_Chakra_Theme ***
we want to Customizing the Chakra Theme to match rawg.io

in Chakara documentation we got to "Styled System" and then in the menu we go to the "default Theme"

we can see see this line  
"We recommend adding a palette that ranges from 50 to 900. Tools like Themera,
 Smart Swatch, Coolors or Palx are available to generate these palettes."

and we can try colors using "Smart Swatch" we can write a number thin click on the colors plate 
to have the value and copy it to our project

now in our theme.ts we have a property called colors here we can set the colors 
-------------------code---------------------
const theme = extendTheme({
  config,
  colors: {
    gray: {},
  },
});
-------------------code---------------------

- now we set the colors 
-------------------code---------------------
const theme = extendTheme({
  config,
  colors: {
    gray: {
      50: "#f9f9f9",
      100: "#ededed",
      200: "#d3d3d3",
      300: "#b3b3b3",
      400: "#a0a0a0",
      500: "#898989",
      600: "#6c6c6c",
      700: "#202020",
      800: "#121212",
      900: "#111",
    },
  },
});
-------------------code---------------------

commit our code 
"Customizing the them to get darker grays"

*** 38-_Refactoring_Game_Grid ***

on our GameGrid we either have error or SimpleGrid instead to render them next to each other
as a best practice is better to use another return statement
-------------------code---------------------
if (error) return <Text>{error}</Text>;

  return (
    <SimpleGrid

    ..)
-------------------code---------------------

with that we don`t have either to use fragment and make our code cleaner
 
now we commit our code 
"Refactor GameGrid"

*** 39-_Building_for_Production ***

we are ready to deploy our Project but first we should run it locally to make sure it doesn`t have error
remmber it easier to check it locally than waiting for deployment to finish 
so to build our application we run "npm run build"  


we can see our application is builded without any errors but we have Warning says 
*********************************************************************
(!) Some chunks are larger than 500 kBs after minification. Consider:
- Using dynamic import() to code-split the application
- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks
- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.
*********************************************************************

we got this error coz our bundle js is over 500 kb 
*********************************************************************
dist/assets/index-f6dd315d.css                    0.02 kB │ gzip:   0.04 kB
dist/assets/index-afd6bf25.js                   537.01 kB │ gzip: 182.27 kB
*********************************************************************

in this part we don`t have to worry a bout it in the next part we will handle it. so we will ignore it 

but what if we have a compiled error to simulate an error in SortSelector.tsx we change onSelectSortOrder to xonSelectSortOrder

-------------------code---------------------
<MenuItem
  onClick={() => xonSelectSortOrder(order.value)}
  key={order.value}
  value={order.value}
>
-------------------code---------------------

we run an error we can see it the terminl we run "npm run build" another time 
*********************************************************************
src/components/SortSelector.tsx:31:30 - error TS2552: Cannot find name 'xonSelectSortOrder'. Did you mean 'onSelectSortOrder'?

31               onClick={() => xonSelectSortOrder(order.value)}
                                ~~~~~~~~~~~~~~~~~~

  src/components/SortSelector.tsx:9:25
    9 const SortSelector = ({ onSelectSortOrder, sortOrder }: Props) => {
                              ~~~~~~~~~~~~~~~~~
    'onSelectSortOrder' is declared here.
    }

Found 1 error in src/components/SortSelector.tsx:31
*********************************************************************

so remmber we can catch error in our application we build it to the production 

using "shif+cmd P" we can select "Task: Run Build Task" then we select "npm build"
or shortcut "shif+cmd B"

PS: the output of the input is file called dist which is shortcut of distributeable, is what we deploy to our production

*** 40-_Deploying_to_Vercel ***
the final part we are going to deploy our application to a platform called Vercel

we can deploy our project with another tools either if we go to 
https://vitejs.dev/

then press on Guide we can see "Deploying a Static Site"
we can multi ways to deploy our project 

but now we will use Vercel
remmber we need to create repository so when add new feature our application will build and push it
to Vercel

- fisrt we create an account in Vercel

- then install Vercel to in our application
"npm i -g vercel"

after we finish we will have question but we will just press enter (default)

then we will have url if we access we can see our project

finally:
we need to link our github to that project 
in our Vercel account we can see our project and "No Git Repository connected" is writin 
so we select it the we go to "Connect Git Repository" then we select "GitHub" and from the list we select
our repository

now if we push changes in our application and push it Vercel will build it for us

to test that in index.html 
we change 
-------------------code---------------------
<title>Vite + React + TS</title>
-------------------code---------------------
to 
-------------------code---------------------
<title>GameShop</title>
-------------------code---------------------

*** Fetching and Updating Data with React Query ***

*** 24-_Exercise-_Fetching_Genres *** 

first we are going to fetch genre using React Query 

- we setup the react query 
-------------------code----------------------
npm i @tanstack/react-query@4.28
npm i @tanstack/react-query-devtools@4.28
-------------------code----------------------


- next we go to main.tsx 
--import the the nessery component for using React Query in our application
-------------------code----------------------
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
-------------------code----------------------

PS: there is two ReactQueryDevtools we import the one with blue icon 

-- craete a new instance of QueryClient
-------------------code----------------------
const queryClient = new QueryClient();
-------------------code----------------------

-- wrap our application with QueryClientProvider and give it the client that we created
-------------------code----------------------
<QueryClientProvider client={queryClient}>
  <App />
</QueryClientProvider>
-------------------code----------------------

-- finally we add our ReactQueryDevtools to our component tree 
-------------------code----------------------
<QueryClientProvider client={queryClient}>
  <App />
  <ReactQueryDevtools />
</QueryClientProvider>
-------------------code----------------------

now we run our application and open the console to make sure everything works without any error 

- now we go to useGenre.ts 
we can see the object that we return from this hook has three properties 
data, isLoading, error 

-- the good thing here is that this object has same shape as the object we return from ReactQuery
so we can easily replace it with useQurey 
PS: we call useQurey make sure to import from transtack not chakraUI 

-- we call the queryKey genres and set queryFn for simplicity geting only the data  
-------------------code----------------------
const useGenres = () =>
  useQuery({
    queryKey: ["genres"],
    queryFn: () => apiClient.get("/genres").then((res) => res.data),
  });
-------------------code----------------------

- now we go to GenreList.tsx to check that we don`t have any error 
we see error where we mapping the genre 
-------------------code----------------------
{data.map((genre) => ...)}
-------------------code----------------------
the error says
-------------------code----------------------
Parameter 'genre' implicitly has an 'any' type.t
-------------------code----------------------

-- so if hover in the data 
-------------------code----------------------
const { data, isLoading, error } = useGenres();
-------------------code----------------------
we can see the type of data is any 

-- to solve that we got to the useGenre.ts and provide a type generic 
-------------------code----------------------
queryFn: () => apiClient.get<Genre[]>("/genres").then((res) => res.data),
-------------------code----------------------

-- now we can see the type of data is genre array 

-- but we have another error says 
-------------------code----------------------
'data' is possibly 'undefined'.
-------------------code----------------------
and that make a sense cause the call to the server could be failed 

so we should use optional chaning 
-------------------code----------------------
{data?.map((genre) => (...))}
-------------------code----------------------

- now we check our application we can see it`s crashed we can see in the console 
-------------------code----------------------
TypeError: data?.map is not a function at GenreList (GenreList.tsx:31:16)
-------------------code----------------------

-- so we press on the 
-------------------code----------------------
GenreList.tsx:31:16
-------------------code----------------------

-- to move to the file inside the Browser and we add break point on the same line 
then refresh with cmd/ctrl + shift + R

-- we can see the data is object with 4 properties
and we can`t iterate over this for properties cause that impossible what we want is to iterate
over the result property 
-------------------code----------------------
data: 
 count: 19
 next: null
 previou: null
 results: Array(19)
 0: {id: 4, name: 'Action', slug: 'action', games_count: 181941, image_background: 'https://media.rawg.io/media/games/b8c/b8c243eaa0fbac8115e0cdccac3f91dc.jpg', …}
 1: {id: 51, name: 'Indie', slug: 'indie', games_count: 68616, image_background: 'https://media.rawg.io/media/games/d0f/d0f91fe1d92332147e5db74e207cfc7a.jpg', …}
 2: {id: 3, name: 'Adventure', slug: 'adventure', games_count: 141620, image_background: 'https://media.rawg.io/media/games/48c/48cb04ca483be865e3a83119c94e6097.jpg', …}
....
-------------------code----------------------


-- now if we put result we see error 
-------------------code----------------------
{data?.result.map((genre) => ()...)}
-------------------code----------------------
-------------------code----------------------
roperty 'result' does not exist on type 'Genre[]'.
-------------------code----------------------

-- so we made mistake instead of using Genre[] 
-------------------code----------------------
queryFn: () => apiClient.get<Genre[]>("/genres").then((res) => res.data),
-------------------code----------------------

-- we should use the type of the response
 (FetchResponse with 4 properties that we defined before in useData.ts) 
at that time we add only count and results cause we are not going to use next and previous

-- so we export the FetchResponse from the useData.ts 
-------------------code----------------------
apiClient.get<FetchResponse<Genre>>("/genres").then((res) => res.data),
-------------------code----------------------
PS: we don`t have to add Genre[] cause we already add type genrec and called with array with result 
-------------------code----------------------
results: T[]
-------------------code----------------------

now we render the genre of the results 
-------------------code----------------------
{data?.results.map((genre) => () ...)}
-------------------code----------------------

- now we check out implomantaion and we can see it works fine 

- we impove our code 
cause genre is hardly coding we want to put the staleTime to 24hours 

24 * 60minutes * 60seconds * 1000 milisecond
-------------------code----------------------
staleTime: 24 * 60 * 60 * 1000, // 24hours
-------------------code----------------------

we will improve the way we write it later but now we want to focus on the implomantaion 


- next we set the Initial data to the static data that we shiped in our application
-------------------code----------------------
initialData: genres
-------------------code----------------------

- we have compilation error in queryKey says 
-------------------code----------------------
No overload matches this call.
  The last overload gave the following error.
    Object literal may only specify known properties, and 'queryKey' does not exist in type 'readonly unknown[]'.
-------------------code----------------------

the error happned cause 
-------------------code----------------------
apiClient.get<FetchResponse<Genre>>("/genres").then((res) => res.data),
-------------------code----------------------

we tell the React qurey that we suppose to have data with type FetchResponse but the initialData that we defined 
in the genres.ts
doesn`t have count and result properties  only array 
to solve that we have two ways
1- 
-------------------code----------------------
initialData: { count: genres.length, results: genres },
-------------------code----------------------

2- inside the genres.ts we add count and results but that will take more works 
so we will go with step one 

- now we check our application
we don`t see a spinner cause our initial data inserted in the query 
beside the data will be stale after 24 hours so no request we go the backend to fetch the genre 



*** 25-_Exercise-_Fetching_Platforms ***

next we are going to fetch the platform using React Query 

this one is similar to the way we do in useGenre.ts 
- in usePlatforms.ts
-------------------code----------------------
const usePlatforms = () =>
  useQuery({
    queryKey: ["platforms"],
    queryFn: () =>
      apiClient
        .get<FetchResponse<Platforms>>("/platforms/lists/parents")
        .then((res) => res.data),
  });
-------------------code----------------------

- PlatformSelector.tsx we fix the mapping of data same as genre 
-------------------code----------------------
{data?.results.map((platform) => ()..)}
-------------------code----------------------

- now we test our code 

- next we improve our implomantaion

PS: i forgot to ship the platform as static data so same as genre we create data/platforms.ts and 
add the data 

-------------------code----------------------
const usePlatforms = () =>
  useQuery({
    queryKey: ["platforms"],
    queryFn: () =>
      apiClient
        .get<FetchResponse<Platforms>>("/platforms/lists/parents")
        .then((res) => res.data),
    staleTime: 24 * 60 * 60 * 1000, // 24hours
    initialData: { count: platforms.length, results: platforms },
  });
-------------------code----------------------

now if we open the console we can see that we only have one API request to the games

*** 26-_Exercise-_Fetching_Games *** 

now we will replace useData hook use useQuery cause everything all the functionality that implomentent in data hook
is already build in better way in query hook 

so we will replace data hook with query hook then remove data hook from the project

as we did before we use in useGames.ts
- we rewrite usedata with useQuery
-------------------code----------------------
const useGames = (gameQuery: GameQuery) =>
  useQuery({
    queryKey: ["games", gameQuery],
    queryFn: () =>
      apiClient
        .get<FetchResponse<Game>>("/games", {
          params: {
            genres: gameQuery.genre?.id,
            parent_platforms: gameQuery.platform?.id,
            ordering: gameQuery.sortOrder,
            search: gameQuery.searchText,
          },
        })
        .then((res) => res.data),
  });
-------------------code----------------------

- clean the import statement 


- now we have duplication in our code we used  interface Platform in to two places useGames and usePlatforms
but now we want to focus in current implomantaion and as a good software engineer we should have a note while we coding 
and write in that note for example fix the deplication of our interfaces so we back later to fix it 
(for me i will add TODO)

-------------------code----------------------
// TODO: fix the duplication of the Platform interface
export interface Platform {
  id: number;
  name: string;
  slug: string;
}
-------------------code----------------------


- now we test our code 

we see white screen wo we opne the console to see the errors 
-------------------code----------------------
Uncaught TypeError: Cannot read properties of undefined (reading 'map')
    at GameGrid (GameGrid.tsx:30:13)
-------------------code----------------------


as we did in PlatformList 
-------------------code----------------------
{data?.results.map((game) => (
        <GameCardContainer key={game.id}>
          <GameCard game={game} />
        </GameCardContainer>
      ))}
-------------------code----------------------


- now we see in the GameGrid.tsx another error 
-------------------code----------------------
<Text>{error}</Text>;
-------------------code----------------------

Type '{}' is not assignable to type 'ReactNode'.ts(2322)

- to fix it we go to useGames.ts and add type genric to the useQuery
-------------------code----------------------
const useGames = (gameQuery: GameQuery) =>
  useQuery<FetchResponse<Game>, Error>({
..})
-------------------code----------------------

- then we go to the GameGrid and render error.message 
-------------------code----------------------
<Text>{error.message}</Text>;
-------------------code----------------------

- now we test our code 
we click on Action genre the on Indie genre 
now if reclick on Action we can see it refresh faster cause the cashe 


- now we remove we useData to remove the useData hook 
PS: before removing any block of code it`s better to check if it reference in another place 
so it will not effect another place
so we go useData and right click on "Go to Refrences"

so we after clicked we can see it refrence in only one place which is the same file so it`s save to remove 

so we can simply remove it 

- now in useData we stil have FetchResponse interface and if press on "Go to Refrences" 
we can see it refrence in 8 diffrent places 

but it doesn`t make any sense to make a useData file to conatain only this function 
cause this file is for data hook
so the right place to move it the apiClient.ts 
-------------------code----------------------
import axios from "axios";

export interface FetchResponse<T> {
  count: number;
  results: T[];
}

export default axios.create({
  baseURL: "https://api.rawg.io/api",
  params: {
    key: import.meta.env.VITE_API_KEY,
  },
});
-------------------code----------------------

as a result of that our import statements will break in multi files 
for now we will remove useData.ts 
then fix the import statement in each file 

after fix all the files to make sure that we don`t have error anywhere else 

cmd + shift + p
and search for Build 
and select 
"Tasks: Run Build Task"

and select npm run vite with our Application location
now we can see we have no errors 


*** 27-_Exercise-_Removing_Duplicate_Interfaces ***
we have Platform interface in two places useGames.ts and usePlatforms.ts
we will remove the duplication from our code 

- as before we said before removing an interface or any method we see it all the Refrences
right click and "Go To Refrences"

first in App.tsx 
- we change import Platform from useGames to usePlatforms
-------------------code----------------------
import { Platform } from "./hooks/usePlatforms";
-------------------code----------------------

and the same for other refrence places

PS: in PlatformSelctor we fix to be like that 
-------------------code----------------------
import usePlatforms, { Platform } from "../hooks/usePlatforms";
-------------------code----------------------

- finally we remove it 

- and to make sure there is no error we build our project


*** 28-_Exercise-_Creating_a_Reusable_API_Client *** 
in all our hooks inside useQurey we dublicate our fetching code 
-------------------code----------------------
apiClient.get<FetchResponse<Genre>>("/genres").then((res) => res.data),
-------------------code----------------------
so we want to resolve this by ceating reusble API Client 

- in api-client.ts instead of export the axios instance we change to contant 
-------------------code----------------------
const axiosInstance = axios.create({
  baseURL: "https://api.rawg.io/api",
  params: {
    key: import.meta.env.VITE_API_KEY,
  },
});
-------------------code----------------------

then we create Class we call it APIClient and give it type generic 
-------------------code----------------------
class APIClient <T>{

}
-------------------code----------------------

- now we give it property called endpoint and insilize it using constractor 
-------------------code----------------------
class APIClient<T> {
  endpoint: string;

  constructor(endpoint: string) {
    this.endpoint = endpoint;
  }
}
-------------------code----------------------

- now in this class we want only one method we called getAll 
and as same as apiClient.get<FetchResponse<Genre>
-------------------code----------------------
class APIClient<T> {
  endpoint: string;

  constructor(endpoint: string) {
    this.endpoint = endpoint;
  }

  getAll() {
    return axiosInstance.get<FetchResponse<T>>(this.endpoint);
  }
}
-------------------code----------------------

- now we call the the logic of  apiClient.get<FetchResponse<Genre> only ones 

now because we use params in useGames we call the config optional property if we hover 
on the get method we can see it 
then we call then method 

-------------------code----------------------
 getAll(config: AxiosRequestConfig) {
    return axiosInstance
      .get<FetchResponse<T>>(this.endpoint, config)
      .then((res) => res.data);
  }
-------------------code----------------------

PS: to aviod this problem we change the getAll to arrow function 

-------------------code----------------------
getAll = (config: AxiosRequestConfig) => {
    return axiosInstance
      .get<FetchResponse<T>>(this.endpoint, config)
      .then((res) => res.data);
  };
-------------------code----------------------

finally we export the class as default
-------------------code----------------------
export default APIClient;
-------------------code----------------------


- now we update our hooks one by one 

- in useGenre.ts we change the import statement to APIClient and remove FetchResponse
cause we no longer need it 
-------------------code----------------------
import APIClient from "../services/api-client";
-------------------code----------------------


- then we create instance of that class and give it the endpoint
-------------------code----------------------
const apiClient = new APIClient<Genre>("/genres");
-------------------code----------------------

finally we replace queryFn with apiClient.getAll 

now we do the same thing with platform 
-------------------code----------------------
import APIClient from "../services/api-client";
-------------------code----------------------

then 
-------------------code----------------------
const apiClient = new APIClient<Platform>("/platforms/lists/parents");
-------------------code----------------------

finally 
-------------------code----------------------
queryFn: apiClient.getAll,
-------------------code----------------------

- now we change useGames 

but in useGame we can`t call apiClient.getAll cause we have params we we should called in this way 
inside the queryFn function and give it param as argument
-------------------code----------------------
queryFn: () =>
      apiClient.getAll({
        params: {
          genres: gameQuery.genre?.id,
          parent_platforms: gameQuery.platform?.id,
          ordering: gameQuery.sortOrder,
          search: gameQuery.searchText,
        },
      }),
-------------------code----------------------

- now we do test to our code 

then commit our code 

*** 29-_Exercise-_Implementing_Infinite_Queries ***

now we will take the application to the next level and imploment Infinite qureys
so we will add button for loading more games 

- in useGames.ts we should change the useQuery wiht useInfiniteQuery 
-------------------code----------------------
useInfiniteQuery<FetchResponse<Game>, Error>({
  queryKey: ["games", gameQuery],
  queryFn: () => ..}) 
-------------------code----------------------

- next we have queryFn to resive our page number as parameter 
so we destruct the parameter to take pageParam and set to 1 
-------------------code----------------------
queryFn: ({ pageParam = 1 }) => ...
-------------------code----------------------

- now if go to the api documentation we can see it have query parameter called page 
which support pagination 
so we grap it and set it to pageParam
-------------------code----------------------
queryFn: ({ pageParam = 1 }) =>
      apiClient.getAll({
        params: {
          genres: gameQuery.genre?.id,
          parent_platforms: gameQuery.platform?.id,
          ordering: gameQuery.sortOrder,
          search: gameQuery.searchText,
          page: pageParam,
        },
      }),
-------------------code----------------------

- next we should call the getNextPageParam un useInfiniteQuery to compute next page number 
this function should take two parameter last page and all pages 
all pages contains tha data for each page we have retrive  so to compute the next page number 
we return all pages number + 1 
-------------------code----------------------
useInfiniteQuery<FetchResponse<Game>, Error>({
    queryKey: ["games", gameQuery],
    queryFn: ({ pageParam = 1 }) =>
      apiClient.getAll({
        params: {
          genres: gameQuery.genre?.id,
          parent_platforms: gameQuery.platform?.id,
          ordering: gameQuery.sortOrder,
          search: gameQuery.searchText,
          page: pageParam,
        },
      }),
    getNextPageParam: (lastPage, allPages) => {
      return allPages.length + 1;
    },
  });
-------------------code----------------------

- now in getNextPageParam we still increament until we hit last page and that time 
query paramter of page will be defined so we need write code says if we reach the last page 

back to the api documentation from the responese we can see that we 
count 
next 
previous
results
until now we only imploment count and results
but if we see next we can see next to it string<ui> Nullable
which means when we reach the last page 
page query paramter => undefined
next (from the fetch responese) => null 

- so we press cmd + t and go to FetchResponse interface 
and add next property 
-------------------code----------------------
export interface FetchResponse<T> {
  count: number;
  next: string | null;
  results: T[];
}
-------------------code----------------------

- now we wirte condition says if the lastPage is truthy return all page number + 1 other wise undefined
-------------------code----------------------
getNextPageParam: (lastPage, allPages) => {
    return lastPage.next ? allPages.length + 1 : undefined;
  },
-------------------code----------------------

- next we go to GameGrid.tsx 
now we have error here cause the data shape was changed 
-------------------code----------------------
{data?.results.map((game) .....)}
-------------------code----------------------

now we should map each page to React fragment and then map each page result to game card container 

-------------------code----------------------
{data?.pages.map((page, index) => (
  <React.Fragment key={index}>
    {page.results.map((game) => (
      <GameCardContainer key={game.id}>
        <GameCard game={game} />
      </GameCardContainer>
    ))}
  </React.Fragment>
))}
-------------------code----------------------

- next we import the functions of InfinityQurey pages 
-------------------code----------------------
const {
    data,
    error,
    isLoading,
    isFetchingNextPage,
    fetchNextPage,
    hasNextPage,
  } = useGames(gameQurey);
-------------------code----------------------

- next we add Button component and we want to render only if there is a next page 
-------------------code----------------------
{hasNextPage && <Button></Button>}
-------------------code----------------------

- next we want to show the button dynamically
-------------------code----------------------
<Button>{isFetchingNextPage ? "isLoading" : "Load More"}</Button>
-------------------code----------------------

- finally we should handle the click event 
-------------------code----------------------
<Button onClick={() => fetchNextPage()}>
  {isFetchingNextPage ? "Loading" : "Load More"}
</Button>
-------------------code----------------------

- the button is a little close to the button to we add vertical margin
-------------------code----------------------
<Button onClick={() => fetchNextPage()} marginY={5}>
  {isFetchingNextPage ? "Loading" : "Load More"}
</Button>
-------------------code----------------------

- aligin our button to Grid but before we add padding="10px" to the SimpleGrid 
now to aviod repetitive we change the fragment to Box and add padding 10px to it 
and remove it form SimpleGrid 
-------------------code----------------------
<Box padding="10px">
<SimpleGrid columns={{ sm: 1, md: 2, lg: 3, xl: 4 }} spacing={6}>
-------------------code----------------------

now we test our InfinityQurey with another geenre and check if we got the right page 
using devtool 


*** 30-_Exercise-_Implementing_Infinite_Scroll ***

now we will make the application better by show games while scroling not clicking a Button 
to do that we are gonna use popular librariy called react-infinite-scroll-component
try read the documentation and imploment it 

- install the librariy
-------------------code----------------------
npm i react-infinite-scroll-component@6.1
-------------------code----------------------

- we go to the GameGrid.tsx and warap SimpleGrid component with InfiniteScroll component
-------------------code----------------------
<InfiniteScroll>
  <SimpleGrid 
  ....
  </SimpleGrid>
</InfiniteScroll>
-------------------code----------------------

- the InfiniteScroll component has multi property we should set 
dataLength: we have to put the number of data that we fetch so far 

- so we define a constat we called fetchedGamesCount and use reduce method 
to reduce this array of pages into a number are present the total number og games 
we have fetch so far, we know that each page of games contain an array og games



ex of reduce method 
-------------------code----------------------
const array1 = [1, 2, 3, 4];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array1.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  initialValue,
);

console.log(sumWithInitial);
// Expected output: 10
-------------------code----------------------


- so we want to combine the games we have in the array 
reduce have two paramter we call the first paramter acc and that refer to the or call it total
the second parameter is the element of the array which is page 
so now in each iteration we have to count the games to that page and add to the total and as 
second argument we should give it the insilize value which is 0 
-------------------code----------------------
const fetchdGamesCount = data?.pages.reduce(
    (total, page) => total + page.results.length,
    0
  );
-------------------code----------------------

- now we can use fetchdGamesCount to set the dataLength prop 
-------------------code----------------------
<InfiniteScroll dataLength={fetchdGamesCount}>
-------------------code----------------------

- now we got compilation error says 
-------------------code----------------------
Type 'number | undefined' is not assignable to type 'number'.
  Type 'undefined' is not assignable to type 'number'.
-------------------code----------------------

- cause data?.pages is a result of fetching and could be undefined
to fix that we give fetchdGamesCount a default value of 0 
-------------------code----------------------
const fetchdGamesCount =
    data?.pages.reduce((total, page) => total + page.results.length, 0) || 0;
-------------------code----------------------

- now the next property called hasMore we set it to hasNextPage
-------------------code----------------------
<InfiniteScroll dataLength={fetchdGamesCount} hasMore={hasNextPage}>
-------------------code----------------------

we have compilation error cause hasMore only accept boolean while hasNextPage has type of boolean | undefined
-------------------code----------------------
Type 'boolean | undefined' is not assignable to type 'boolean'.
  Type 'undefined' is not assignable to type 'boolean'.
-------------------code----------------------

- now to fix that we !! before hasNextPage to convert it to actual boolean value 
so if it undefined that means it`s falsy so the result will be false 
-------------------code----------------------
<InfiniteScroll dataLength={fetchdGamesCount} hasMore={!!hasNextPage}>
-------------------code----------------------

- next we add the next props and call the fetchNextPage
-------------------code----------------------
<InfiniteScroll
  dataLength={fetchdGamesCount}
  hasMore={!!hasNextPage}
  next={() => fetchNextPage()}
>
-------------------code----------------------

- finally we set the loader method is what to show the user while fetching the games 
so we set to Spinner 
-------------------code----------------------
 <InfiniteScroll
        dataLength={fetchdGamesCount}
        hasMore={!!hasNextPage}
        next={() => fetchNextPage()}
        loader={<Spinner />}
      >
-------------------code----------------------

- now we test our implomantaion

- finally we don`t need the Load Button anymore so we remove it 
and that`s also means we don`t need the Box component anymore  so we move the padding to our 
SimpleGrid and remove the Box component 
-------------------code----------------------
<SimpleGrid
          columns={{ sm: 1, md: 2, lg: 3, xl: 4 }}
          spacing={6}
          padding="10px"
        >
-------------------code----------------------

- finally we remove unnecessary import statements by pressing orginize the import statement

- one more thing to add staleTime to the useGames hook 
-------------------code----------------------
 staleTime: 24 * 60 * 60 * 1000, // 24h
-------------------code----------------------

now we commit our code 


*** 31-_Exercise-_Simplifying_Query_Objects ***

the next step we want to improve is the game query object 
in our application we select a genre for example indie then we open the dev tool 
-------------------code----------------------
[
  "games",
  {
    "genre": {
      "id": 51,
      "name": "Indie",
      "slug": "indie",
      "games_count": 66814,
      "image_background": "https://media.rawg.io/media/games/baf/baf9905270314e07e6850cffdb51df41.jpg",
      "games": [
        {
          "id": 1030,
          "slug": "limbo",
          "name": "Limbo",
          "added": 13436
        }, ...
      ]}
  }
]
-------------------code----------------------

in our object where we store the games we have over complexity  we have games at first then genre then again a games 
obviously we don`t need any of this stuff here to filter games by genre all we need is the genre id 

- in App.tsx when we select a geenre 
-------------------code----------------------
onSelectedGenre={(genre) => setGameQuery({ ...gameQuery, genre })}
-------------------code----------------------

we return this all (genre) complex object
what we want to do is to replace all the genre object with genre id 

the same thing we want to do for the platform 
-------------------code----------------------
onSelectPlatform={(platform) =>
                  setGameQuery({ ...gameQuery, platform })
                }
-------------------code----------------------

- now when the user select the genre we want to store the genre id in our game qurey object

- first we look at the gameQurey interface 
-------------------code----------------------
export interface GameQuery {
  genre: Genre | null;
  platform: Platform | null;
  sortOrder: string;
  searchText: string;
}
-------------------code----------------------

- before change the genre we right click on genre and check for the refrences 
we can see there is only 3 places where it used 

so we change it to number 
-------------------code----------------------
export interface GameQuery {
  genre: number | null;
  platform: Platform | null;
  sortOrder: string;
  searchText: string;
}
-------------------code----------------------

- why we put instaed of null an undefined
undefined: the absence of a value 
null: the intenational absence of a value 

******************************************************************
undefined and null represent different concepts regarding the 
absence of a value:

undefined:
This indicates that a variable has been declared
but has not yet been assigned a value. It is the default state of uninitialized variables.
Example:
-------------------code----------------------
let x; // x is declared but not initialized
console.log(x); // Output: undefined
-------------------code----------------------

null:
This is an intentional assignment of "no value." It is used to explicitly indicate that a variable should have no value.
Example:
let y = null; // y is explicitly set to have no value
console.log(y); // Output: null
******************************************************************

- in this case in our application we can use undefined
initially our user doen`t select the genre yet 
but ones set select the genre they can`t unselected it 
so platform and genre could be undefined instad of null 

-------------------code----------------------
export interface GameQuery {
  genre: number | undefined;
  platform: Platform | undefined;
  sortOrder: string;
  searchText: string;
}
-------------------code----------------------

PS: we can simple our code by add ? optional chain 
-------------------code----------------------
export interface GameQuery {
  genre?: number;
  platform: Platform | null;
  sortOrder: string;
  searchText: string;
}
-------------------code----------------------


******************************************************************

In TypeScript, when you declare a property like genre?: number, it means that the property is optional and can be either:
- number
- undefined

This is equivalent to number | undefined. The ? indicates that the property may not be present at all,
which results in it being undefined if it is not provided.

If you want to allow the property to be null as well, you would declare it like this:
-------------------code----------------------
genre: number | null | undefined;
-------------------code----------------------

In summary:
genre?: number means number | undefined.
genre: number | null | undefined means it can be a number, null, or undefined.

we can check the type by hover on the genre?: 
******************************************************************

- before refactor the platform we will refactor the genre then we will refactor
the platform 

- now for making the property more clarify we change it name genreId so the we 
can know that we should apply id 
-------------------code----------------------
export interface GameQuery {
  genreId?: number;
  platform: Platform | null;
  sortOrder: string;
  searchText: string;
}
-------------------code----------------------

- now we go the other refrence for updating 

(App.tsx) we change it to genreId 
-------------------code----------------------
<GenreList
  selectedGenre={gameQuery.genreId}
  onSelectedGenre={(genre) => setGameQuery({ ...gameQuery, genreId })}
/>
-------------------code----------------------


- we still have error 

Type 'number | undefined' is not assignable to type 'Genre | null'.
  Type 'undefined' is not assignable to type 'Genre | null'.

- by Clicking to GenreList we go to GenreList.tsx
the error happing here because we compary the genre.id with all selectedGenre.id
but after we changeed the value of genre to only genre id 
our code right now 
selectedGenre = genreIdd so it`s like id.id?
-------------------code----------------------
fontWeight={genre.id === selectedGenre?.id ? "bold" : "normal"}
-------------------code----------------------

- to fix that we change the selectedGenre of Props 
first we rename it to selectedGenreId then we set the type to number optional chain (number | undefined)
-------------------code----------------------
interface Props {
  onSelectedGenre: (genre: Genre) => void;
  selectedGenreId?: number;
}
-------------------code----------------------

- then fix the props in the function 
-------------------code----------------------
const GenreList = ({ selectedGenreId, onSelectedGenre }: Props) => { ..}
-------------------code----------------------

- finally fix the code where we render the font size 
-------------------code----------------------
fontWeight={genre.id === selectedGenreId ? "bold" : "normal"}
-------------------code----------------------

- now we back to App.tsx 
we fix the property name to selectedGenreId 
and fix genreId of setGameQuery to genreId: genre.id 
-------------------code----------------------
<GenreList
  selectedGenreId={gameQuery.genreId}
  onSelectedGenre={(genre) =>
    setGameQuery({ ...gameQuery, genreId: genre.id })
  }
/>
-------------------code----------------------

- now we back to the GameQuery interface and go to the genreId refrence 
next we go to GameHeading.tsx 

******************************************************************
PS: when we open the Refrences first the first time don`t close it until fix all the refrence
but if close it accidently rewrite the property name ex:
-------------------code----------------------
export interface GameQuery {
  genre: number,
  genreId?: number;
  platform: Platform | null;
  sortOrder: string;
  searchText: string;
}
-------------------code----------------------
******************************************************************

- in GameHeading.tsx we have error where we are getting the name of genre 
-------------------code----------------------
const heading = `${gameQuery?.platform?.name || ""} 
  ${gameQuery.genre?.name || ""}
-------------------code----------------------

we can fix by take the name using hook 
- so we call the useGenres hook and rename the data to genres for clarifying 
-------------------code----------------------
const { data: genres } = useGenres();
const genre = genres?.results.find((g) => g.id === gameQuery.genreId);
-------------------code----------------------

- finally we render it name 
-------------------code----------------------
${genre?.name || ""}
-------------------code----------------------

- now we go to the next refrence and remove the genre: number, we set it 
next refrence is useGames and fix to genre id 
-------------------code----------------------
params: {
          genres: gameQuery.genreId,
          ...}
-------------------code----------------------

- now before apply the same refactor to the platform the check if our code is working

our code work fine and our qurey object is simpilar 
-------------------code----------------------
["games",{"genreId":3}]
-------------------code----------------------


- now we apply the same thing to our platform qurey
- first we open the refrence and keep it then we change the interface property name 
-------------------code----------------------
export interface GameQuery {
  genreId?: number;
  platformId?: number;
  sortOrder: string;
  searchText: string;
}
-------------------code----------------------


- we fix the first refrence in App.tsx same as genre
-------------------code----------------------
<PlatformSelector
  selectedPlatformId={gameQuery.platformId}
  onSelectPlatform={(platform) =>
    setGameQuery({ ...gameQuery, platformId: platform.id })
  }
></PlatformSelector>
-------------------code----------------------

the go to PlatformSelector.tsx fix the Props 
-------------------code----------------------
interface Props {
  onSelectPlatform: (platform: Platform) => void;
  selectedPlatformId?: number;
}
-------------------code----------------------


- selcet the platform from the hook 
-------------------code----------------------
const selectedPlatform = data?.results.find(
    (p) => p.id === selectedPlatformId
  );
-------------------code----------------------

- next we go the next refrence GameHeading.tsx we replay the code 
from PlatformSelector where we use the hook for now, next we will refactor our entire code 

-------------------code----------------------
const { data: platforms } = usePlatforms();
  const selectedPlatform = platforms?.results.find(
    (p) => p.id === gameQuery.platformId
  );
-------------------code----------------------


- next we go the next refrence useGames.ts amd chnage the params 
-------------------code----------------------
params: {
          genres: gameQuery.genreId,
          parent_platforms: gameQuery.platformId, ..}
-------------------code----------------------

now we test the code 

our qurey object
-------------------code----------------------
["games",{"platformId":4}]
-------------------code----------------------

- finally in all the file we use optimize imports 



*** 32-_Exercise-_Creating_Lookup_Hooks ***
we have this logic in two places 
- GameHeading.tsx 
- PlatformSelctor.tsx
-------------------code----------------------
const { data: platforms } = usePlatforms();
  const selectedPlatform = platforms?.results.find(
    (p) => p.id === gameQuery.platformId
  );
-------------------code----------------------

- for avioding the complexity we will incapsulate this logic inisde custom reusble hook 
and we can use it for platform and even genre 
-------------------code----------------------
const { data: genres } = useGenres();
const genre = genres?.results.find((g) => g.id === gameQuery.genreId);
-------------------code----------------------

- inside the hooks folder we create file called usePlatform.ts 
we define function that take id as parameter then we export at the end 
-------------------code----------------------
const usePlatform = (id: number) => {
  
};

export default usePlatform;
-------------------code----------------------

- now inside we should have the logic of looking to platform by id 
so we will copy the code from GameHeading looking of id and paste inside usePlatform hook 
-------------------code----------------------
const usePlatform = (id: number) => {
  const { data, error } = usePlatforms();
  const selectedPlatform = data?.results.find(
    (p) => p.id === selectedPlatformId
  );
};

export default usePlatform;
-------------------code----------------------

- we import usePlatforms hook and change the selectedPlatformId with id 
-------------------code----------------------
import usePlatforms from "./usePlatforms";

const usePlatform = (id: number) => {
  const { data: platforms } = usePlatforms();
  const selectedPlatform = platforms?.results.find(
    (p) => p.id === gameQuery.platformId
  );
};

export default usePlatform;
-------------------code----------------------

instead of define selectedPlatform we return it immediately

-------------------code----------------------
const usePlatform = (id: number) => {
  const { data: platforms } = usePlatforms();
  return platforms?.results.find((p) => p.id === id);
};
-------------------code----------------------

- now we go to GameHeading.tsx and call usePlatform and give it gameQuery.platformId
as parameter and it return object we save in platform constant
-------------------code----------------------
const platform = usePlatform(gameQuery.platformId);
-------------------code----------------------

we got type error says gameQuery.platformId should be defined so we set the id 
parameter of usePlatform to optional
-------------------code----------------------
const usePlatform = (id?: number) => {
  const { data: platforms } = usePlatforms();
  return platforms?.results.find((p) => p.id === id);
};
-------------------code----------------------

-  then we callit instad of selectedPlatform
-------------------code----------------------
const heading = `${platform?.name || ""} 
-------------------code----------------------

- now we do the same thing for PlatformSelector
instead of this code 
-------------------code----------------------
  const selectedPlatform = data?.results.find(
    (p) => p.id === selectedPlatformId
  );
-------------------code----------------------

we call usePlatform and the same way as GameHeading.tsx 
-------------------code----------------------
const platform = usePlatform(selectedPlatformId);
-------------------code----------------------

then we fix where we render the name 
-------------------code----------------------
{platform?.name || "Platforms"}
-------------------code----------------------



- next we will write the same way to lock to the genre by id 

- create useGenre.ts and take the code from the GameHeading.tsx and return 
immediately

-------------------code----------------------
import useGenres from "./useGenres";

const useGenre = (id?: number) => {
  const { data: genres } = useGenres();
  return genres?.results.find((g) => g.id === id);
};

export default useGenre;
-------------------code----------------------

- we call it in GameHeading
-------------------code----------------------
const genre = useGenre(gameQuery.genreId);
-------------------code----------------------

- now we test our code 
if platform name and genre rendering without a problems 


- now we had a previous problem in the genre hook 
we have error at the queryKey property
there is no wrong with the key the problem is somewher else in queryFn or initialData 


-  we hover on apiClient.getAll  we see 
-------------------code----------------------
(property) APIClient<Genre>.getAll: (config: AxiosRequestConfig) => Promise<FetchResponse<Genre>>
-------------------code----------------------

so it return fetch object of type Response and this the object that will store in the cache
of genres key 

and if check of the type of initialData we can see it 
-------------------code----------------------
(property) initialData?: (() => undefined) | undefined
-------------------code----------------------

and it`s diffrent from the fetch Response so here we have initial data type diffrent from the fetch Response type 
so if commnet out the initialData property the error goes away 

- we can add next: null and error goes
-------------------code----------------------
useQuery({
    queryKey: ["genres"],
    queryFn: apiClient.getAll,
    staleTime: 24 * 60 * 60 * 1000, // 24hours
    initialData: { count: genres.length, results: genres, next: null },
  });
-------------------code----------------------

- but this is a hack so what if we decide in future to add more property to the FetchResponse interface
again we have to remmber to come here and fix the issue 

- so a better approach is to modify the static data and make exacly same as the response we get it 
from our backend so currently in static data we have only the array of genre and next and result 
and previous and count property are missing 


- so we commnet out the initial values first 
-------------------code----------------------
// initialData: { count: genres.length, results: genres, next: null },
-------------------code----------------------

- then we go the application and refresh then we go to the genre request and click on "Response" tab 
then copy everything then export it 
-------------------code----------------------
export default {
  count: 19,
  next: null,
  previous: null,
  results: [
    {
      id: 4,
    ... } ]}
-------------------code----------------------


- finally we set the initial data to genres
-------------------code----------------------
  useQuery({
    queryKey: ["genres"],
    queryFn: apiClient.getAll,
    staleTime: 24 * 60 * 60 * 1000, // 24hours
    initialData: genres,
  });
-------------------code----------------------


- now we have the same issue with platforms
so we comment the initial data and copy the data from the "Response" 

-------------------code----------------------
export default {
  count: 14,
  next: null,
  previous: null,
  results: [
    {
      id: 1,
      name: "PC",
      slug: "pc",
      platforms: [
        {... } ]} ] }
-------------------code----------------------


- then we set the initial data 
-------------------code----------------------
const usePlatforms = () =>
  useQuery({
    queryKey: ["platforms"],
    queryFn: apiClient.getAll,
    staleTime: 24 * 60 * 60 * 1000, // 24hours
    initialData: platforms,
  });
-------------------code----------------------

- finally we orginize the imports to all the changed files 

and test our code 


*** 33-_Exercise-_Simplifying_Time_Calculations ***

- we have two issue when we set the staleTime 
first: we need to remmber to add commnet, if we forgot it will be unreadable 
second: even if we add a comment we can`t know which one is of the numbers is seconds or minutues and so 

- we can simplify the time using librariy called "ms"
https://www.npmjs.com/package/ms

it`s very popular if we saw the weekly downloads (PS: when using a librariy make sure that it famous so 
it`s updates frequency )

- we can arguing that why we need to add a new librariy for only simplify our time readability 
is not the best way and it will incerase the bundle that we shiped to the client 
but in the documentation we can see the the size is only 6.72 kb so the impcat is minimum
beside we can create methods to simplify the time without librariy but we are going to study how 
to use "ms" librariy 

- PS: it`s very simple try to do it by your self so to learn how to imploment a package
while reading the documentation

- how to set it

- we install it by using npm 
-------------------code----------------------
npm i ms@2.1.3
-------------------code----------------------


- now we go to useGenres.ts 
-------------------code----------------------
import ms from "ms"
-------------------code----------------------

- but we go error cause ms is not support the types of TypeScript so we need to install the type
seperately
-------------------code----------------------
ms' is declared but its value is never read.ts(6133)
Could not find a declaration file for module 'ms'. '/Users/mahmouddabbbagh/moody/React18/Mahmoud/game-hub/node_modules/ms/index.js' implicitly has an 'any' type.
  Try `npm i --save-dev @types/ms` if it exists or add a new declaration (.d.ts) file containing `declare module 'ms';
-------------------code----------------------

- we install type and we want to add the types only for development
cause in production the TypeScript compiled to JavaScript 
-------------------code----------------------
npm i --save-dev @types/ms 
// or we can use -D
npm i --D @types/ms
-------------------code----------------------

- now the error if import statement goes away
-------------------code----------------------
const useGenres = () =>
  useQuery({
    queryKey: ["genres"],
    queryFn: apiClient.getAll,
    staleTime: ms("24h"),
    initialData: genres,
  });
-------------------code----------------------

- we need to do the same thing to the other hooks 

useGames and usePlatforms

then we comment our code 
