*** 2-_Consolidating_State_Logic_with_a_Reducer ***
Reducer: a function that allows us to centralize state updates in a component

the underline meaning we will see it in action 
- now we have component called counter for increment and decrement a number 
in the component we two components where we update the state 
-------------------code----------------------
onClick={() => setValue(value + 1)}  // when increment 
onClick={() => setValue(0)} className="btn btn-primary mx-1" // when decrement 
-------------------code----------------------

- there is nothing terrible here but as the component gets complex 
keeping track if how the state is updated can get a little challenging here where we can use the 
Reducer, using the Reducer we can take all the management logic outside this component and centralized it 
in a single function 

- how to do that 
- inside the state-management folder we create reducers folder inside it we create a file called "counterReducer"
the Reducer function must have two parameters the first parameter the state and the second one it`s action 
action: is an object that describe what is the user is trying to do 
so the reducer take state and action and return a new state 
-------------------code----------------------
const counterReducer = (state, action) => {};

export default counterReducer;
-------------------code----------------------

- so what the type of state we go back the Counter.tsx and the initial value to the useState is 0 which means 
the type is number 

- for action there is no rule, we can use simple string but by convention we use type property that 
describe the action we create interface with type string and called Action.

-------------------code----------------------
interface Action {
  type: string;
}

const counterReducer = (state: number, action: Action) => {
  
};
-------------------code----------------------

- we give the function a return type of number so if we made a mistake the compiler while yell at us 

-------------------code----------------------
const counterReducer = (state: number, action: Action): number => {};
-------------------code----------------------

- when we set the return value to number we immediately got an error cause we didn`t set the return value 
if we return a 0 the error will go away 

- now we write condition like 
-------------------code----------------------
const counterReducer = (state: number, action: Action): number => {
  if (action.type === "INCREMENT") return state + 1;
};
-------------------code----------------------

- the same thing for the reset 
-------------------code----------------------
const counterReducer = (state: number, action: Action): number => {
  if (action.type === "INCREMENT") return state + 1;
  if (action.type === "RESET") return 0;
};
-------------------code----------------------

- but what if the action is a different type
some people said we should thew error 

-------------------code----------------------
const counterReducer = (state: number, action: Action): number => {
  if (action.type === "INCREMENT") return state + 1;
  if (action.type === "RESET") return 0;
  throw new Error("Action is not supported");
};
-------------------code----------------------

- but cause TS is already have type checking for the function and we set it number no need to throw error just return the state
-------------------code----------------------
const counterReducer = (state: number, action: Action): number => {
  if (action.type === "INCREMENT") return state + 1;
  if (action.type === "RESET") return 0;
  return state;
};
-------------------code----------------------

- now we go back to the Counter.tsx we no more need the useState instead we use useReducer hook that 
hook take two arguments the first one is reducer function the second one is second argument is the initial value
-------------------code----------------------
// const [value, setValue] = useState(0);
useReducer(counterReducer, 0);
-------------------code----------------------

and this hook similar to state hook will return an array with two elements the first element is the 
current state "value" as before the second element is a function configuring changes called dispatch means send in english 
-------------------code----------------------
const [value, dispatch] = useReducer(counterReducer, 0);
-------------------code----------------------

- when user click a that button so instead of set the value we send an action using dispatch with object
contain type property of INCREMENT
-------------------code----------------------
onClick={() => dispatch({ type: "INCREMENT" })}
-------------------code----------------------

- so when we dispatch an action we trying to tell React that the user is trying to increment the value 
React will go to the counterReducer function and return state + 1


- now back to our component similarly when the user click on the reset button we set the type to RESET
-------------------code----------------------
onClick={() => dispatch({ type: "RESET" })}
-------------------code----------------------

- now we have a little issue if write reset in lower case or add space after the word our useReducer
will not work to fix that

by setting the type property to this two values
-------------------code----------------------
interface Action {
  type: "INCREMENT" | "RESET";
}
-------------------code----------------------

- now with our reducer we have better separation of concern and we can reuse this producer in other Components
that works with our counter

now we test our implementation 

*** 3-_Creating_Complex_Actions ***

now we will try with more complex component we will render TaskList.tsx in App.tsx 
inside the TaskList component there is two places where we update the state 
where we add a task
-------------------code----------------------
setTasks([
  { id: Date.now(), title: 'Task ' + Date.now() },
  ...tasks,
])
-------------------code----------------------

and where we delete a task
-------------------code----------------------
onClick={() =>
  setTasks(tasks.filter((t) => t.id !== task.id))
}
-------------------code----------------------

now we can do the same thing and define a reducers so in the reducers folder we create a new file we 
call it tasksReducer.ts

-------------------code----------------------
const tasksReducer = (state, action) => {};

export default tasksReducer;
-------------------code----------------------

now to set the type of state we got to TaskList.tsx and we can see the type of useState is Task[]
-------------------code----------------------
const [tasks, setTasks] = useState<Task[]>([]);
-------------------code----------------------

- so we set the reducer state type to Task[]
-------------------code----------------------
const tasksReducer = (state: Task[], action) => {};
-------------------code----------------------

- so now we need to access the Task interface so we move it to the tasksReducer.ts
-------------------code----------------------
interface Task {
  id: number;
  title: string;
}

const tasksReducer = (state: Task[], action) => {};
-------------------code----------------------

- now for clarity we name the state parameter to tasks, next we define the Action interface
-------------------code----------------------
interface Task {
  id: number;
  title: string;
}

type Action = {
  type: "ADD" | "DELETE";
};

const tasksReducer = (tasks: Task[], action: Action) => {};

export default tasksReducer;
-------------------code----------------------

- now we add the type of the return statement which Task[]
-------------------code----------------------
const tasksReducer = (tasks: Task[], action: Action) :Task[] 
-------------------code----------------------

- before we used if statement but we can use either switch and case 
-------------------code----------------------
const tasksReducer = (tasks: Task[], action: Action) :Task[] => {
  switch (action.type) {
    case "ADD":
    return [{}, ...tasks]
  }
};
-------------------code----------------------

- when returning a new object [{}, ..tasks] we return the original array then we add the new tasks 
so we need to access to the old tasks but that is not necessary when deleting the tasks 
so we delete the interface Action and and two interfaces one for adding and one for deleting 
-------------------code----------------------
type AddTask = {
  type: "ADD";
  task: Task;
};

type DeleteTask = {
  type: "DELETE";
  taskId: number;
};
-------------------code----------------------

- finally we define a type we called TaskAction and it can be reunion of the AddTask and DeleteTask 
-------------------code----------------------
type AddTask = {
  type: "ADD";
  task: Task;
};

type DeleteTask = {
  type: "DELETE";
  taskId: number;
};

type TaskAction = AddTask | DeleteTask;
-------------------code----------------------

- finally we write the return statements
-------------------code----------------------
const tasksReducer = (tasks: Task[], action: TaskAction): Task[] => {
  switch (action.type) {
    case "ADD":
      return [action.task, ...tasks];
    case "DELETE":
      return tasks.filter((t) => t.id !== action.taskId);
  }
};
-------------------code----------------------


PS: in case ADD when we type action. the compiler show the task but not the taskId cause 
it know we already work with AddTask interface cause the action.type is number 
same thing for DELETE we see taskId but not task 


- now we goes back to our TaskList to apply the useReducer
-------------------code----------------------
const [tasks, dispatch] = useReducer(tasksReducer, []);
-------------------code----------------------

- now when the user click on add button 
-------------------code----------------------
 onClick={() =>
  dispatch({
    type: "ADD",
    task: { id: Date.now(), title: "Task " + Date.now() },
  })}
-------------------code----------------------


- now when we delete a button 
-------------------code----------------------
onClick={() => dispatch({ type: "DELETE", taskId: task.id })}
-------------------code----------------------

now we test our code 

*** 4-_Exercise-_Working_with_Reducers ***
as exercise will we create reducer for LoginStatus.tsx 
- authReducer.ts 
-------------------code----------------------
type LoginAction = {
  type: "LOGIN";
  userName: string;
};

type LogoutAction = {
  type: "LOGOUT";
};

type AuthAction = LoginAction | LogoutAction;

const authReducer = (state: string, action: AuthAction): string => {
  switch (action.type) {
    case "LOGIN":
      return action.userName;

    case "LOGOUT":
      return "";

    default:
      return state;
  }
};

export default authReducer;
-------------------code----------------------

- LoginStatus
-------------------code----------------------
const [user, dispatch] = useReducer(authReducer, "");
-------------------code----------------------

-------------------code----------------------
onClick={() => dispatch({ type: "LOGOUT" })}
-------------------code----------------------

-------------------code----------------------
onClick={() => dispatch({ type: "LOGIN", userName: "moody" })}
-------------------code----------------------

*** 5-_Sharing_State_using_React_Context ***
before we talk a bout sharing state:
lift the state up to the closest parent and pass it down as props to child component

but if have 
-------------------code----------------------
App
HomePage   NavBar
TaskList 
-------------------code----------------------

and want to share the state between the TaskList and NAVBAR we lift up to App but we have a problem 
after pass it up to App component we have to pass it down to both HomePage and NavBar beside TaskList 
knowing that we are not going to use it in HomePage

- here where we can use ReactContext
ReactContext: sharing data without passing down through many components in the middle

- see it in action
in TaskList component we are using the useReducer to maintain the local state 
so both the state and the reducer hook are ways to maintain local state in the component

so to share this state we have to lift it up to the App component and then we can provide it to a component
using a context 

- so first we move the useReducer code from the TaskList to the App.ts 
-------------------code----------------------
const [tasks, dispatch] = useReducer(tasksReducer, []);
-------------------code----------------------

- so we want to provide it to TaskList component using Context so inside the state-management folder 
we create a folder we called it contexts inside it we create file we called it taskContext.ts

- context is like a track inside that track is a state, so first we have to define the shape of that box
so we define interface we called it 
-------------------code----------------------
interface TaskContextType {
  
}
-------------------code----------------------


- to know the shape of box we go to App.tsx and look to useReducer method 
so we know we have array of tasks and dispatch function
so we need to path this two object so we can access them anyWhere 

- we export the Task interface and TaskAction type  form tasksReducer.ts 
- and hover over the dispatch function to know the type and set it in the interface
-------------------code----------------------
interface TaskContextType {
  tasks: Task[];
  dispatch: Dispatch<TaskAction>;
}
-------------------code----------------------

PS: if want to check the type of dispatch we click cmd + click to Dispatch import 
-------------------code----------------------
type Dispatch<A> = (value: A) => void;
-------------------code----------------------

we can see type Dispatch is take a generic type of A and return void

- now we call React.Context to share the state and give it the type of the TaskContextType 
that we define 

-------------------code----------------------
React.createContext<TaskContextType>();
-------------------code----------------------

- we have to give it argument as default value and now we have two options first to give it null 
but in this case we have to set the type tp null either and that will not make a sense cause 
we will end up sharing null statement 
-------------------code----------------------
React.createContext<TaskContextType | null>(null);
-------------------code----------------------

as a best practice is better to set the default value to empty object 
-------------------code----------------------
React.createContext<TaskContextType>({});
-------------------code----------------------

but will we will have error 
-------------------code----------------------
Argument of type '{}' is not assignable to parameter of type 'TaskContextType'.
-------------------code----------------------

so we can tell the compiler this empty object is an instance of a TaskContextType
by using as keyword 
-------------------code----------------------
React.createContext<TaskContextType>({} as TaskContextType);
-------------------code----------------------

- finally we create a instance of that context and export it
-------------------code----------------------
const TaskContext = React.createContext<TaskContextType>({} as TaskContextType);

export default TaskContext;
-------------------code----------------------

- now in our App component we call NavBar and HomePage components
-------------------code----------------------
<>
  <NavBar></NavBar>
  <HomePage></HomePage>
</>
-------------------code----------------------

- then to pass the state to two of them we pass we wrap them inside a ReactContext.Provider component
in our case TaskContext instance that we created 
-------------------code----------------------
<>
  <TaskContext.Provider>
    <NavBar></NavBar>
    <HomePage></HomePage>
  </TaskContext.Provider>
</>
-------------------code----------------------

PS: we call the TaskContext as component that`s why we name it in capital letters 

- now we need to provide a value to that component this value is the return state 
which is tasks and dispatch
-------------------code----------------------
<>
  <TaskContext.Provider value={{ tasks, dispatch }}>
    <NavBar></NavBar>
    <HomePage></HomePage>
  </TaskContext.Provider>
</>
-------------------code----------------------

- TaskContext.Provider is like a track that transporting the state that we provide inside the NavBar
and the HomePage component

- now to access this box inside the the TaskList component we call the useContext of type 
TaskContext and return the context 
-------------------code----------------------
const context = useContext(TaskContext);
-------------------code----------------------

now context contain tasks and dispatch and is the box that we shipped using the React Context

- so we access the property by destructuring the object
-------------------code----------------------
const { tasks, dispatch } = useContext(TaskContext);
-------------------code----------------------

- now let`s try to share the state using the useContext in NavBar to return the dynamic number of tasks 
instead of 4 number 
-------------------code----------------------
<span className="badge text-bg-secondary">4</span>
-------------------code----------------------

- so first we call useContext and destructuring tasks and render the tasks length
-------------------code----------------------
const { tasks } = useContext(TaskContext);
  return (
    <nav className="navbar d-flex justify-content-between">
      <span className="badge text-bg-secondary">{tasks.length}</span>
      <LoginStatus />
    </nav>
  );
-------------------code----------------------

now we test our code 

Recap:
share state using React context
1- lift the state up to the closest parent
2- create a context (track transporting box which have our local state)
3- we wrap ourComponent tree with TaskContext (where we want to use the state we call it using useContext)
