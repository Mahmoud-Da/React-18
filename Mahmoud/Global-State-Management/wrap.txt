*** 2-_Consolidating_State_Logic_with_a_Reducer ***
Reducer: a function that allows us to centralize state updates in a component

the underline meaning we will see it in action 
- now we have component called counter for increment and decrement a number 
in the component we two components where we update the state 
-------------------code----------------------
onClick={() => setValue(value + 1)}  // when increment 
onClick={() => setValue(0)} className="btn btn-primary mx-1" // when decrement 
-------------------code----------------------

- there is nothing terrible here but as the component gets complex 
keeping track if how the state is updated can get a little challenging here where we can use the 
Reducer, using the Reducer we can take all the management logic outside this component and centralized it 
in a single function 

- how to do that 
- inside the state-management folder we create reducers folder inside it we create a file called "counterReducer"
the Reducer function must have two parameters the first parameter the state and the second one it`s action 
action: is an object that describe what is the user is trying to do 
so the reducer take state and action and return a new state 
-------------------code----------------------
const counterReducer = (state, action) => {};

export default counterReducer;
-------------------code----------------------

- so what the type of state we go back the Counter.tsx and the initial value to the useState is 0 which means 
the type is number 

- for action there is no rule, we can use simple string but by convention we use type property that 
describe the action we create interface with type string and called Action.

-------------------code----------------------
interface Action {
  type: string;
}

const counterReducer = (state: number, action: Action) => {
  
};
-------------------code----------------------

- we give the function a return type of number so if we made a mistake the compiler while yell at us 

-------------------code----------------------
const counterReducer = (state: number, action: Action): number => {};
-------------------code----------------------

- when we set the return value to number we immediately got an error cause we didn`t set the return value 
if we return a 0 the error will go away 

- now we write condition like 
-------------------code----------------------
const counterReducer = (state: number, action: Action): number => {
  if (action.type === "INCREMENT") return state + 1;
};
-------------------code----------------------

- the same thing for the reset 
-------------------code----------------------
const counterReducer = (state: number, action: Action): number => {
  if (action.type === "INCREMENT") return state + 1;
  if (action.type === "RESET") return 0;
};
-------------------code----------------------

- but what if the action is a different type
some people said we should thew error 

-------------------code----------------------
const counterReducer = (state: number, action: Action): number => {
  if (action.type === "INCREMENT") return state + 1;
  if (action.type === "RESET") return 0;
  throw new Error("Action is not supported");
};
-------------------code----------------------

- but cause TS is already have type checking for the function and we set it number no need to throw error just return the state
-------------------code----------------------
const counterReducer = (state: number, action: Action): number => {
  if (action.type === "INCREMENT") return state + 1;
  if (action.type === "RESET") return 0;
  return state;
};
-------------------code----------------------

- now we go back to the Counter.tsx we no more need the useState instead we use useReducer hook that 
hook take two arguments the first one is reducer function the second one is second argument is the initial value
-------------------code----------------------
// const [value, setValue] = useState(0);
useReducer(counterReducer, 0);
-------------------code----------------------

and this hook similar to state hook will return an array with two elements the first element is the 
current state "value" as before the second element is a function configuring changes called dispatch means send in english 
-------------------code----------------------
const [value, dispatch] = useReducer(counterReducer, 0);
-------------------code----------------------

- when user click a that button so instead of set the value we send an action using dispatch with object
contain type property of INCREMENT
-------------------code----------------------
onClick={() => dispatch({ type: "INCREMENT" })}
-------------------code----------------------

- so when we dispatch an action we trying to tell React that the user is trying to increment the value 
React will go to the counterReducer function and return state + 1


- now back to our component similarly when the user click on the reset button we set the type to RESET
-------------------code----------------------
onClick={() => dispatch({ type: "RESET" })}
-------------------code----------------------

- now we have a little issue if write reset in lower case or add space after the word our useReducer
will not work to fix that

by setting the type property to this two values
-------------------code----------------------
interface Action {
  type: "INCREMENT" | "RESET";
}
-------------------code----------------------

- now with our reducer we have better separation of concern and we can reuse this producer in other Components
that works with our counter

now we test our implementation 

*** 3-_Creating_Complex_Actions ***

now we will try with more complex component we will render TaskList.tsx in App.tsx 
inside the TaskList component there is two places where we update the state 
where we add a task
-------------------code----------------------
setTasks([
  { id: Date.now(), title: 'Task ' + Date.now() },
  ...tasks,
])
-------------------code----------------------

and where we delete a task
-------------------code----------------------
onClick={() =>
  setTasks(tasks.filter((t) => t.id !== task.id))
}
-------------------code----------------------

now we can do the same thing and define a reducers so in the reducers folder we create a new file we 
call it tasksReducer.ts

-------------------code----------------------
const tasksReducer = (state, action) => {};

export default tasksReducer;
-------------------code----------------------

now to set the type of state we got to TaskList.tsx and we can see the type of useState is Task[]
-------------------code----------------------
const [tasks, setTasks] = useState<Task[]>([]);
-------------------code----------------------

- so we set the reducer state type to Task[]
-------------------code----------------------
const tasksReducer = (state: Task[], action) => {};
-------------------code----------------------

- so now we need to access the Task interface so we move it to the tasksReducer.ts
-------------------code----------------------
interface Task {
  id: number;
  title: string;
}

const tasksReducer = (state: Task[], action) => {};
-------------------code----------------------

- now for clarity we name the state parameter to tasks, next we define the Action interface
-------------------code----------------------
interface Task {
  id: number;
  title: string;
}

type Action = {
  type: "ADD" | "DELETE";
};

const tasksReducer = (tasks: Task[], action: Action) => {};

export default tasksReducer;
-------------------code----------------------

- now we add the type of the return statement which Task[]
-------------------code----------------------
const tasksReducer = (tasks: Task[], action: Action) :Task[] 
-------------------code----------------------

- before we used if statement but we can use either switch and case 
-------------------code----------------------
const tasksReducer = (tasks: Task[], action: Action) :Task[] => {
  switch (action.type) {
    case "ADD":
    return [{}, ...tasks]
  }
};
-------------------code----------------------

- when returning a new object [{}, ..tasks] we return the original array then we add the new tasks 
so we need to access to the old tasks but that is not necessary when deleting the tasks 
so we delete the interface Action and and two interfaces one for adding and one for deleting 
-------------------code----------------------
type AddTask = {
  type: "ADD";
  task: Task;
};

type DeleteTask = {
  type: "DELETE";
  taskId: number;
};
-------------------code----------------------

- finally we define a type we called TaskAction and it can be reunion of the AddTask and DeleteTask 
-------------------code----------------------
type AddTask = {
  type: "ADD";
  task: Task;
};

type DeleteTask = {
  type: "DELETE";
  taskId: number;
};

type TaskAction = AddTask | DeleteTask;
-------------------code----------------------

- finally we write the return statements
-------------------code----------------------
const tasksReducer = (tasks: Task[], action: TaskAction): Task[] => {
  switch (action.type) {
    case "ADD":
      return [action.task, ...tasks];
    case "DELETE":
      return tasks.filter((t) => t.id !== action.taskId);
  }
};
-------------------code----------------------


PS: in case ADD when we type action. the compiler show the task but not the taskId cause 
it know we already work with AddTask interface cause the action.type is number 
same thing for DELETE we see taskId but not task 


- now we goes back to our TaskList to apply the useReducer
-------------------code----------------------
const [tasks, dispatch] = useReducer(tasksReducer, []);
-------------------code----------------------

- now when the user click on add button 
-------------------code----------------------
 onClick={() =>
  dispatch({
    type: "ADD",
    task: { id: Date.now(), title: "Task " + Date.now() },
  })}
-------------------code----------------------


- now when we delete a button 
-------------------code----------------------
onClick={() => dispatch({ type: "DELETE", taskId: task.id })}
-------------------code----------------------

now we test our code 

*** 4-_Exercise-_Working_with_Reducers ***
as exercise will we create reducer for LoginStatus.tsx 
- authReducer.ts 
-------------------code----------------------
type LoginAction = {
  type: "LOGIN";
  userName: string;
};

type LogoutAction = {
  type: "LOGOUT";
};

type AuthAction = LoginAction | LogoutAction;

const authReducer = (state: string, action: AuthAction): string => {
  switch (action.type) {
    case "LOGIN":
      return action.userName;

    case "LOGOUT":
      return "";

    default:
      return state;
  }
};

export default authReducer;
-------------------code----------------------

- LoginStatus
-------------------code----------------------
const [user, dispatch] = useReducer(authReducer, "");
-------------------code----------------------

-------------------code----------------------
onClick={() => dispatch({ type: "LOGOUT" })}
-------------------code----------------------

-------------------code----------------------
onClick={() => dispatch({ type: "LOGIN", userName: "moody" })}
-------------------code----------------------

