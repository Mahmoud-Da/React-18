*** 2-_What_is_React_Query ***
in this file 
react-course-part2-starter-main/src/react-query/TodoList.tsx
we have the code to fetch the data from the backend

-------------------code----------------------
const [todos, setTodos] = useState<Todo[]>([]);
  const [error, setError] = useState('');

  useEffect(() => {
    axios
      .get('https://jsonplaceholder.typicode.com/todos')
      .then((res) => setTodos(res.data))
      .catch((error) => setError(error));
  }, []);

  if (error) return <p>{error}</p>;
-------------------code----------------------

but we have multi issues:
1- No request cancelation:
if our component is not mounted there is not request cancelation
PS: coz we strict mode is enabled we end up send request to the server twice

2- No separation of concerns:
our backend code and our frontend code are next to each other 
if someone else need the data we to duplicate the useEffect hook in other component

3- No retries:
if there is an error we show the user only an error and move on and tha is not the best user experience

4- No automatic refresh:
if the data changes while the user on this page. they don`t see the chages unless they 
refresh


5- No caching:
caching : the prosses of storing data in a place where it can be accessed more quickly and efficiently 
in the future.

ex: we can store frequently data in frontend side (inside the user Browser) so we don`t have to fetch 
it from the server everytime we need it
and this can improve the performance of our application.

now we have 5 problems and everytime we fetch data we need to care a bout them.
so here where "React Query" come to rescue.
React Query:
a powerful library for managing data fetching and caching in React applications

alot of people using "Redux" for caching
Redux: a popular state managment library for JavaScript applications
it allow us to store the state or the data in our application in single global store (java script object in user Browser)
so a lot of people using that data we have in global store for caching
but:

Redux:           
- Difficult to learn 
- so much boilerplate code so it make our code hard to maintaine

React Query:
- a lot simpler
- More lightwight code

so Redux is no longer needed for too much cases at least for caching
PS: do not use Redux for caching

and if we want to maintaine old project with Redux see if you can replace it with React Query


*** 3-_Setting_Up_React_Query ***
to install React Query in our application we install it
using command line 
-------------------code----------------------
npm i @tanstack/react-query@4.28
-------------------code----------------------

then we go to main.tsx
-------------------code----------------------
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
-------------------code----------------------

QueryClient: is the core object for managing and caching data in React Query

so we create instacne of QueryClient
-------------------code----------------------
const queryClient = new QueryClient()
-------------------code----------------------

then we wrap App component with QueryClientProvider component and set the client property
to the queryClient

-------------------code----------------------
<React.StrictMode>
  <QueryClientProvider client={queryClient}>
    <App />
  </QueryClientProvider>
</React.StrictMode>
-------------------code----------------------

*** 4-_Fetching_Data ***
now to fetch data with React Query we go to TodoList.tsx
and we use useQuery hook that defined in tanstack

we call it and give it a configration object with two properties
1- qureyKey: which is a unique identifier for the qurey it used for caching
so when we want to get the data from backend the data will be saved in the Browser cache
and it will be accessble by the qureyKey.

we set it the array of one or more values the first value is where we define the type
of the data that we want store in our useQuery hook in our case "todos" and we can have and object 
to set which data we want store normally it depends on our project

ex:
-------------------code----------------------
{queryKey: ["todos", {completed: true}]}
-------------------code----------------------

but now we want to make it simple so we stick in one value "todos"
PS: todos we take it from the endpoint
https://jsonplaceholder.typicode.com/todos

2- qureyFn: and this the function where we use it to fetch the data form the backend
this function return a promise that result the data or throw an error 

so first we pass an arrow function and inisde it we fetch the data
PS: inside we can use any http librariy not only axios
-------------------code----------------------
queryFn: () => axios.get("https://jsonplaceholder.typicode.com/todos"),
-------------------code----------------------

so useQuery will be like this 
-------------------code----------------------
useQuery({
    queryKey: ["todos"],
    queryFn: () => axios.get("https://jsonplaceholder.typicode.com/todos"),
  });
-------------------code----------------------

useQuery it deosn`t care a bout how we fetch the data it`s only responsible how we 
managing and cacheing data 

now axios.get is return the responese object but we don`t want to store all the responese in our cache
instead we only want to store the actual data that we get from the backend

so after the get method we call then to get the response and return only the data
-------------------code----------------------
useQuery({
    queryKey: ["todos"],
    queryFn: () =>
      axios
        .get("https://jsonplaceholder.typicode.com/todos")
        .then((res) => res.data),
  });
-------------------code----------------------

we can also move the fetching statment to another function

-------------------code----------------------
const fetchTodos = () =>
    axios
      .get("https://jsonplaceholder.typicode.com/todos")
      .then((res) => res.data);

  useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

now if we hover on our fetchTodos function we can see it return Promise of type any
-------------------code----------------------
const fetchTodos: () => Promise<any>
-------------------code----------------------

and "any" not a desired TypeScript Type so to get advantage of TS we have to be more specific
in otherword we want this promise to return not any an array of todos 
so we fix the get method and give a TS type generic

PS: Todo interface is already defined 
-------------------code----------------------
.get<Todo[]>("https://jsonplaceholder.typicode.com/todos")
-------------------code----------------------

next we store the result cache qurey in qurey constant
-------------------code----------------------
const query = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

or we can destructuring the value to get only the data 
-------------------code----------------------
const { data } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

now we have our Qurey look like that 
-------------------code----------------------
const fetchTodos = () =>
    axios
      .get<Todo[]>("https://jsonplaceholder.typicode.com/todos")
      .then((res) => res.data);

  const { data } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

with useQuery hook we don`t need useState any more so we remove this code 
and we don`t the Effect hook so we delete it 
-------------------code----------------------
const [todos, setTodos] = useState<Todo[]>([]);
const [error, setError] = useState("");

useEffect(() => {
    axios
      .get("https://jsonplaceholder.typicode.com/todos")
      .then((res) => setTodos(res.data))
      .catch((error) => setError(error));
  }, []);
-------------------code----------------------

for the error handling we will do it later so we comment it 
-------------------code----------------------
// if (error) return <p>{error}</p>;
-------------------code----------------------

now in the return statement we can 
-------------------code----------------------
<ul className="list-group">
      {data.map((todo) => (
        <li key={todo.id} className="list-group-item">
          {todo.title}
        </li>
      ))}
    </ul>
-------------------code----------------------

but if data hard name to understand we can use union 
-------------------code----------------------
const { data: todos } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

then we reference it in the return statement
-------------------code----------------------
<ul className="list-group">
  {todos.map((todo) => (
    <li key={todo.id} className="list-group-item">
      {todo.title}
    </li>
  ))}
</ul>
-------------------code----------------------

now we have error todos' is possibly 'undefined'. 
coz maybe the calling to backend may fail and todos will be undefined at that time 
so we should use optional chaining
-------------------code----------------------
<ul className="list-group">
  {todos?.map((todo) => (
    <li key={todo.id} className="list-group-item">
      {todo.title}
    </li>
  ))}
</ul>
-------------------code----------------------

with this implomantaion we have multi benifits:
- Auto Retries:
if the call to the server failed React Qurey will try a couple times 

- Auto Refetch:
we can configure the Qurey to refetch after a period of time 

- Caching:
so the first time we get the data from the backend it will store in the cache
and stay for period of time so next time we want that data we don`t have to Call the 
Server again 

and this improve the performance of our application

*** 5-_Handling_Errors ***

useQuery also have property called error to handle the errors for tracking the error may happen 
when fetching the data 
-------------------code----------------------
const { data: todos, error } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
});
-------------------code----------------------

no we uncommit our error statement
-------------------code----------------------
if (error) return <p>{error}</p>;
-------------------code----------------------

but we have complation error says:
-------------------code----------------------
Type '{}' is not assignable to type 'ReactNode'.
-------------------code----------------------

so React doesn`t know how render the error object
but why if we looked the type of error property of useQuery we can`t see it as unknown
so React Qurey doesn`nt know the type of error may not happen while fetching data coz that is depends
a about how we fetch the data (are we using axios or default fetch method or another librariy)

now we are using axios so in axios all the errors are instacnes of the Error interface that is available
in all the Browsers 

now if we type in useQuery <
ex:
-------------------code----------------------
useQuery<
-------------------code----------------------

we can see all the default type generic 
-------------------code----------------------
useQuery<TQueryFnData = unknown, TError = unknown,
 TData = TQueryFnData, 
 TQueryKey extends QueryKey = QueryKey>(options:
  Omit<UseQueryOptions<TQueryFnData, TError, TData
  , TQueryKey>, "initialData">
   & { initialData?: () => undefined; })
   : UseQueryResult<TData, TError>
-------------------code----------------------

TQueryFnData: is the type generic of the data which we fetched from the backend
TError: type of errors

and know we can leave the other values for default and change only TQueryFnData, and TError
-------------------code----------------------
const { data: todos, error } = useQuery<Todo[], Error>({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

now if we hove on the error we can see the type is Error | null 

finally we can fix the error object by render one of the Error properties in 
-------------------code----------------------
if (error) return <p>{error.message}</p>;
-------------------code----------------------

finally we go to App.tsx and return TodoList 
-------------------code----------------------
function App() {
  return <TodoList />;
}
-------------------code----------------------

finally we run "npm run dev" to check our project
