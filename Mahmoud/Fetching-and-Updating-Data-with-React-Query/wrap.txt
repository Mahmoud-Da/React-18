*** 2-_What_is_React_Query ***
in this file 
react-course-part2-starter-main/src/react-query/TodoList.tsx
we have the code to fetch the data from the backend

-------------------code----------------------
const [todos, setTodos] = useState<Todo[]>([]);
  const [error, setError] = useState('');

  useEffect(() => {
    axios
      .get('https://jsonplaceholder.typicode.com/todos')
      .then((res) => setTodos(res.data))
      .catch((error) => setError(error));
  }, []);

  if (error) return <p>{error}</p>;
-------------------code----------------------

but we have multi issues:
1- No request cancelation:
if our component is not mounted there is not request cancelation
PS: coz we strict mode is enabled we end up send request to the server twice

2- No separation of concerns:
our backend code and our frontend code are next to each other 
if someone else need the data we to duplicate the useEffect hook in other component

3- No retries:
if there is an error we show the user only an error and move on and tha is not the best user experience

4- No automatic refresh:
if the data changes while the user on this page. they don`t see the chages unless they 
refresh


5- No caching:
caching : the prosses of storing data in a place where it can be accessed more quickly and efficiently 
in the future.

ex: we can store frequently data in frontend side (inside the user Browser) so we don`t have to fetch 
it from the server everytime we need it
and this can improve the performance of our application.

now we have 5 problems and everytime we fetch data we need to care a bout them.
so here where "React Query" come to rescue.
React Query:
a powerful library for managing data fetching and caching in React applications

alot of people using "Redux" for caching
Redux: a popular state managment library for JavaScript applications
it allow us to store the state or the data in our application in single global store (java script object in user Browser)
so a lot of people using that data we have in global store for caching
but:

Redux:           
- Difficult to learn 
- so much boilerplate code so it make our code hard to maintaine

React Query:
- a lot simpler
- More lightwight code

so Redux is no longer needed for too much cases at least for caching
PS: do not use Redux for caching

and if we want to maintaine old project with Redux see if you can replace it with React Query


*** 3-_Setting_Up_React_Query ***
to install React Query in our application we install it
using command line 
-------------------code----------------------
npm i @tanstack/react-query@4.28
-------------------code----------------------

then we go to main.tsx
-------------------code----------------------
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
-------------------code----------------------

QueryClient: is the core object for managing and caching data in React Query

so we create instacne of QueryClient
-------------------code----------------------
const queryClient = new QueryClient()
-------------------code----------------------

then we wrap App component with QueryClientProvider component and set the client property
to the queryClient

-------------------code----------------------
<React.StrictMode>
  <QueryClientProvider client={queryClient}>
    <App />
  </QueryClientProvider>
</React.StrictMode>
-------------------code----------------------

*** 4-_Fetching_Data ***
now to fetch data with React Query we go to TodoList.tsx
and we use useQuery hook that defined in tanstack

we call it and give it a configration object with two properties
1- qureyKey: which is a unique identifier for the qurey it used for caching
so when we want to get the data from backend the data will be saved in the Browser cache
and it will be accessble by the qureyKey.

we set it the array of one or more values the first value is where we define the type
of the data that we want store in our useQuery hook in our case "todos" and we can have and object 
to set which data we want store normally it depends on our project

ex:
-------------------code----------------------
{queryKey: ["todos", {completed: true}]}
-------------------code----------------------

but now we want to make it simple so we stick in one value "todos"
PS: todos we take it from the endpoint
https://jsonplaceholder.typicode.com/todos

2- qureyFn: and this the function where we use it to fetch the data form the backend
this function return a promise that result the data or throw an error 

so first we pass an arrow function and inisde it we fetch the data
PS: inside we can use any http librariy not only axios
-------------------code----------------------
queryFn: () => axios.get("https://jsonplaceholder.typicode.com/todos"),
-------------------code----------------------

so useQuery will be like this 
-------------------code----------------------
useQuery({
    queryKey: ["todos"],
    queryFn: () => axios.get("https://jsonplaceholder.typicode.com/todos"),
  });
-------------------code----------------------

useQuery it deosn`t care a bout how we fetch the data it`s only responsible how we 
managing and cacheing data 

now axios.get is return the responese object but we don`t want to store all the responese in our cache
instead we only want to store the actual data that we get from the backend

so after the get method we call then to get the response and return only the data
-------------------code----------------------
useQuery({
    queryKey: ["todos"],
    queryFn: () =>
      axios
        .get("https://jsonplaceholder.typicode.com/todos")
        .then((res) => res.data),
  });
-------------------code----------------------

we can also move the fetching statment to another function

-------------------code----------------------
const fetchTodos = () =>
    axios
      .get("https://jsonplaceholder.typicode.com/todos")
      .then((res) => res.data);

  useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

now if we hover on our fetchTodos function we can see it return Promise of type any
-------------------code----------------------
const fetchTodos: () => Promise<any>
-------------------code----------------------

and "any" not a desired TypeScript Type so to get advantage of TS we have to be more specific
in otherword we want this promise to return not any an array of todos 
so we fix the get method and give a TS type generic

PS: Todo interface is already defined 
-------------------code----------------------
.get<Todo[]>("https://jsonplaceholder.typicode.com/todos")
-------------------code----------------------

next we store the result cache qurey in qurey constant
-------------------code----------------------
const query = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

or we can destructuring the value to get only the data 
-------------------code----------------------
const { data } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

now we have our Qurey look like that 
-------------------code----------------------
const fetchTodos = () =>
    axios
      .get<Todo[]>("https://jsonplaceholder.typicode.com/todos")
      .then((res) => res.data);

  const { data } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

with useQuery hook we don`t need useState any more so we remove this code 
and we don`t the Effect hook so we delete it 
-------------------code----------------------
const [todos, setTodos] = useState<Todo[]>([]);
const [error, setError] = useState("");

useEffect(() => {
    axios
      .get("https://jsonplaceholder.typicode.com/todos")
      .then((res) => setTodos(res.data))
      .catch((error) => setError(error));
  }, []);
-------------------code----------------------

for the error handling we will do it later so we comment it 
-------------------code----------------------
// if (error) return <p>{error}</p>;
-------------------code----------------------

now in the return statement we can 
-------------------code----------------------
<ul className="list-group">
      {data.map((todo) => (
        <li key={todo.id} className="list-group-item">
          {todo.title}
        </li>
      ))}
    </ul>
-------------------code----------------------

but if data hard name to understand we can use union 
-------------------code----------------------
const { data: todos } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

then we reference it in the return statement
-------------------code----------------------
<ul className="list-group">
  {todos.map((todo) => (
    <li key={todo.id} className="list-group-item">
      {todo.title}
    </li>
  ))}
</ul>
-------------------code----------------------

now we have error todos' is possibly 'undefined'. 
coz maybe the calling to backend may fail and todos will be undefined at that time 
so we should use optional chaining
-------------------code----------------------
<ul className="list-group">
  {todos?.map((todo) => (
    <li key={todo.id} className="list-group-item">
      {todo.title}
    </li>
  ))}
</ul>
-------------------code----------------------

with this implomantaion we have multi benifits:
- Auto Retries:
if the call to the server failed React Qurey will try a couple times 

- Auto Refetch:
we can configure the Qurey to refetch after a period of time 

- Caching:
so the first time we get the data from the backend it will store in the cache
and stay for period of time so next time we want that data we don`t have to Call the 
Server again 

and this improve the performance of our application

*** 5-_Handling_Errors ***

useQuery also have property called error to handle the errors for tracking the error may happen 
when fetching the data 
-------------------code----------------------
const { data: todos, error } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
});
-------------------code----------------------

no we uncommit our error statement
-------------------code----------------------
if (error) return <p>{error}</p>;
-------------------code----------------------

but we have complation error says:
-------------------code----------------------
Type '{}' is not assignable to type 'ReactNode'.
-------------------code----------------------

so React doesn`t know how render the error object
but why if we looked the type of error property of useQuery we can`t see it as unknown
so React Qurey doesn`nt know the type of error may not happen while fetching data coz that is depends
a about how we fetch the data (are we using axios or default fetch method or another librariy)

now we are using axios so in axios all the errors are instacnes of the Error interface that is available
in all the Browsers 

now if we type in useQuery <
ex:
-------------------code----------------------
useQuery<
-------------------code----------------------

we can see all the default type generic 
-------------------code----------------------
useQuery<TQueryFnData = unknown, TError = unknown,
 TData = TQueryFnData, 
 TQueryKey extends QueryKey = QueryKey>(options:
  Omit<UseQueryOptions<TQueryFnData, TError, TData
  , TQueryKey>, "initialData">
   & { initialData?: () => undefined; })
   : UseQueryResult<TData, TError>
-------------------code----------------------

TQueryFnData: is the type generic of the data which we fetched from the backend
TError: type of errors

and know we can leave the other values for default and change only TQueryFnData, and TError
-------------------code----------------------
const { data: todos, error } = useQuery<Todo[], Error>({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
-------------------code----------------------

now if we hove on the error we can see the type is Error | null 

finally we can fix the error object by render one of the Error properties in 
-------------------code----------------------
if (error) return <p>{error.message}</p>;
-------------------code----------------------

finally we go to App.tsx and return TodoList 
-------------------code----------------------
function App() {
  return <TodoList />;
}
-------------------code----------------------

finally we run "npm run dev" to check our project

*** 6-_Showing_a_Loading_Indicator ***

the use Query have another property called isLoading 
-------------------code----------------------
const {
    data: todos,
    error,
    isLoading,
  } = useQuery<Todo[], Error>({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });

  if (isLoading) return <p>is Loading ...</p>;
-------------------code----------------------

in useQuery everything is taking care of error , loading we don`t have to write it 
separatly 

*** 7-_Creating_a_Custom_Query_Hook ***
now in our implomantaion we have problem we don`t have the separation of concerns
coz our Query logic is inside our component

to separate our frontend and backend code we create inside react-qurey folder 
a hooks folder 
and inside we create useTodos.ts 

inisde the useTodos.ts  we create constant and export it as default
object
-------------------code----------------------
const useTodos = () => {
  
};

export default useTodos;
-------------------code----------------------

- now back to our component and copy the fetchTodos function and the Todo interface
and we import axios
-------------------code----------------------
import axios from "axios";

interface Todo {
  id: number;
  title: string;
  userId: number;
  completed: boolean;
}

const useTodos = () => {
  const fetchTodos = () =>
    axios
      .get<Todo[]>("https://jsonplaceholder.typicode.com/todos")
      .then((res) => res.data);
};

export default useTodos;
-------------------code----------------------

now we in useTodos hook we should call the useQuery hook and return qurey object
so we copy the useQuery from our component and return 
-------------------code----------------------
const useTodos = () => {
  const fetchTodos = () =>
    axios
      .get<Todo[]>("https://jsonplaceholder.typicode.com/todos")
      .then((res) => res.data);
  return useQuery<Todo[], Error>({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });
};
-------------------code----------------------

now all we do in our component is to call useTodos()
-------------------code----------------------
const { data: todos, error, isLoading } = useTodos();
-------------------code----------------------

finally we remove the unnecessary import statements


*** 8-_Using_React_Query_DevTools ***
React Query comes with own dev tools 
in our terminal
-------------------code----------------------
npm i @tanstack/react-query-devtools@4.28
-------------------code----------------------

now in the main.tsx 
-------------------code----------------------
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
-------------------code----------------------

PS: when import select the second one with blue icon 

then we should add to our component after rendering App
-------------------code----------------------
QueryClientProvider client={queryClient}>
  <App />
  <ReactQueryDevtools />
</QueryClientProvider>
-------------------code----------------------

so this is will only be included in our development and when we build 
our project for production it will not be included

now in our Browser we can see Red Icon and have the content of our cache

now if click on out todos qurey
we can see 
Observers: 1

Observers: is the number of components that use this qurey

now if the this 1 component in not mounted (removed from the screen) Observers will be 0 and the query will
be inactive 
inactive qures will eventually get garbage collected and removed from the cache

we have multi Actions:
we can refetch it or invalidate it or reset it 
and we can even trigger loading or erros 

Data Explorer:
with Data we can see data Exploere we can use our data 

Query Explorer:
we can see multi opttion like cacheTime: 300000
we can see that the cache will be removed after 5 minutes

*** 9-_Customizing_Query_Settings ***
our Qurey has settings that set to default but we can also customize this settings

in main.tsx when we created an instacne of QueryClient we can pass configration
object 
first we pass the object with defaultOptions then we pass another object
called queries
with that we can overwrite the default settings
-------------------code----------------------
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {

    }
  }
});
-------------------code----------------------

*************
options
1- retry: 3 
that means of the queries failed to read the data it will try 3 times

to check it we change the endpoint by adding x to the endpoint
-------------------code----------------------
.get<Todo[]>("https://xjsonplaceholder.typicode.com/todos")
-------------------code----------------------
now we can see in Network tab 4 requests 
the first one is initial and 3 tries 

2- cacheTime: 300_000 // 5 minutes 
the value in miliseconds and the default value is 5 minutes and here
 where we set the the cashe time after 5 minutes the cache will be invalid 
 and it will be collected by the cache garbage


3- staleTime: 0
how long the data consider fresh the default value is 0 that means the moment we have
some data it treated as old  so the next time we need the same piece of data ReactQuery 
will fetch the data from the backend 
to simulate it we change it value to 10 * 1000 // 10 seconds 
and we press in the red icon we can see the todos in orange 

PS: the data Auto Refresh
- when the Network is reconnected 
- when the component is mounted
- when the window is refocused (when we open another tap in the Browser
and go back to our original tab)

to disapled we change the default value (true) to false 
4- refetchOnReconnect: false
5- refetchOnMount: false
6- refetchOnWindowFocus: false

*************

How Refetching in React Query:

when data is stale(old):
React Query  -------------->   Backend
    |        fetch the data
    |
    |   while at the same time return the 
    |   stale data to the cache  application
    ↓
Component

with this approch we can show the user the cashe data immediately while also
getting the latest data in the background  


React Query  -------------->   Backend
    |        
    |        <--------------
    |      when we have the updated data
    |        React Query will update the cache and notify 
    |      our component that a new data is available
    |
    ↓
Component   => finally our component we will render with fresh data 

normally we don`t have to play with all the settings but the most changed one 
is staleTime and that depends on our queries

-------------------code----------------------
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 3,
      cacheTime: 300_000, // 5 minutes
      staleTime: 10 * 1000, // 10 seconds
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      refetchOnMount: false,
    },
  },
});
-------------------code----------------------

in our application we will remove the global settings instead 
in useTodos.ts we set the staleTime for only todos
so remmber we can overwrite the settings globally using main.tsx
or for each endpoint diffrently 
-------------------code----------------------
const useTodos = () => {
  const fetchTodos = () =>
    axios
      .get<Todo[]>("https://jsonplaceholder.typicode.com/todos")
      .then((res) => res.data);
  return useQuery<Todo[], Error>({
    queryKey: ["todos"],
    queryFn: fetchTodos,
    staleTime: 10 * 1000,
  });
};
-------------------code----------------------


*** 10-_Exercise-_Fetching_Data ***
use the React Query for PostList.tsx 

*** 11-_Parameterized_Queries ***
how we can fetch nested resources  exaple we have 
a selected form for 3 users when we select each one
we see diffrent posts 

so first in PostList.tsx we add select element with bootstrap class to make nice
-------------------code----------------------
<select className="form-select mb3"></select>
-------------------code----------------------


for this demo we will hard code the user not fetching
but in the real application we fetch it from the backend
-------------------code----------------------
<select className="form-select mb3">
  <option value=""></option>
  <option value="1">User1</option>
  <option value="2">User2</option>
  <option value="3">User3</option>
</select>
-------------------code----------------------

- now we need to declear a static varible to keep track 
of the selected user so when the user select we should 
filter the post according to that user 

-------------------code----------------------
const [userId, setUserID] = useState<number>();
-------------------code----------------------

- next we should handle the event chages
-------------------code----------------------
<select
  onChange={(event) => setUserID(parseInt(event.target.value))}
  className="form-select mb3"
>
  <option value="">All Users</option>
  <option value="1">User1</option>
  <option value="2">User2</option>
  <option value="3">User3</option>
</select>
-------------------code----------------------

PS: we used parseInt coz the user id should be number but the value 
in the option element is string 

next we should set the value props to the userId so in the next render 
the right option  got selected
-------------------code----------------------
<select
  onChange={(event) => setUserID(parseInt(event.target.value))}
  value={userId}
  className="form-select mb3"
>
  <option value=""></option>
  <option value="1">User1</option>
  <option value="2">User2</option>
  <option value="3">User3</option>
</select>
-------------------code----------------------

- now the last part which is filter
curruntly we are using the usePosts hook we shuold pass the 
userId as parameter so we can filter posts by that ids 

first we pass userId as argument 
-------------------code----------------------
const { data: posts, error, isLoading } = usePosts(userId);
-------------------code----------------------

then add as parameter. user may not be selected that why we add or undefined
-------------------code----------------------
const usePosts = (userId: number | undefined)
-------------------code----------------------

now we have to handle the queryKey 
we handle same as we design out API URLs
we start with top level object which called users 
ex:
/users/1/posts
-------------------code----------------------
queryKey: ["users", userId, "posts"],
-------------------code----------------------

with that everytime the userId changed React will fetch the posts 
for that user 
- finally we pass it to backend
way1
-------------------code----------------------
.get(`https://jsonplaceholder.typicode.com/posts?userId=${userId}`)
-------------------code----------------------

but better to use this way 
-------------------code----------------------
.get("https://jsonplaceholder.typicode.com/posts", {
        params: {
          userId,
        },
      })
-------------------code----------------------

now we can check our cashe tools
when we select User2 
-------------------code----------------------
1 ["users",2,"posts"]
0 ["users",null,"posts"]
-------------------code----------------------

the cashe ["users",2,"posts"] will be 1 which means active 

when reselect All Users 
["users",null,"posts"] will be 1
and 
["users",2,"posts"] will be 0

now another issue when we have all users 
-------------------code----------------------
["users",null,"posts"]
-------------------code----------------------
is a little ugly and it`s better to be only posts 
when the user is empty
-------------------code----------------------
["posts"]
-------------------code----------------------

to fix that 
-------------------code----------------------
queryKey: userId ? ["users", userId, "posts"] : ["posts"],
-------------------code----------------------

one last thing when we select the User for the first time we see 
loading indicator coz the first time we select a user we fetch the data 
from the backend while the next time we select the same user 
we no longer see the loading indicator coz we get the data from the cashe

*** 12-_Paginated_Queries ***

first we should declear a state varible to keep track of currunt page
and insilize it to 1 (first page)
-------------------code----------------------
const [page, setPage] = useState(1);
-------------------code----------------------

cause the page size doesn`t change we don`t a state varible for page size
we can define a normal constant 
-------------------code----------------------
const pageSize = 10
-------------------code----------------------

- now we don`t want to give multi parameter to usePosts hook
it will make our code ugly and hard to maintaine instade we define 
query object 

-------------------code----------------------
const { data: posts, error, isLoading } = usePosts(userId);
-------------------code----------------------

- so we go usePosts.ts and define interface called PostQuery{}
-------------------code----------------------
interface PostQuery {
  userId: number | undefined;
  page: number;
  pageSize: number;
}
-------------------code----------------------

and set the parameter for usePosts hook 
-------------------code----------------------
const usePosts = (query: PostQuery) => {

}
-------------------code----------------------

- set the params 
-------------------code----------------------
axios
    .get("https://jsonplaceholder.typicode.com/posts", {
      params: {
        userId: query.userId,
        _start: (query.page - 1) * query.pageSize,
        _limit: query.pageSize,
      },
    })
-------------------code----------------------

- now back to our component we call the queryObjects inside the usePosts 
-------------------code----------------------
const {
    data: posts,
    error,
    isLoading,
  } = usePosts({ userId, page, pageSize });
-------------------code----------------------

- now if we back to our Browser we can see only ten posts 

- next we add button for pagination 
now the Previous should be disable if we are in the first page
and when clicked we go back one page 
-------------------code----------------------
<button
  disabled={page === 1}
  className="btn btn-primary"
  onClick={() => setPage(page - 1)}
>
  Previous
</button>
-------------------code----------------------

 
- the same thing for nextPage 
here we removed the disable property coz placeHolder API doesn`t
tell the last page number 
-------------------code----------------------
<button className="btn btn-primary" onClick={() => setPage(page + 1)}>
  Next
</button>
-------------------code----------------------

now cause the button is too close we give them a vertical margin 
and we give the next buttn margin left (in bootstrap 5 its ms (means margin start))
-------------------code----------------------
<button
  disabled={page === 1}
  className="btn btn-primary my-3 "
  onClick={() => setPage(page - 1)}
>
  Previous
</button>
<button
  className="btn btn-primary my-3 ms-1"
  onClick={() => setPage(page + 1)}
>
  Next
</button>
-------------------code----------------------

- now one problem is that when press the next button the loading indicator
shows and the page move to the top
we can have a improve the experience for the user by shiping the data in the 
current page while waiting for the new data 
and when the new data is available we swap the data of the current page 

it easy to do, by setting keepPreviousData to true 
-------------------code----------------------
queryKey: ["posts", query],
    queryFn: fetchPosts,
    staleTime: 1 * 60 * 1000, // 1m
    keepPreviousData: true,
-------------------code----------------------

*** 13-_Infinite_Queries ***
to show Infinite Queries first we use useInfiniteQurey instead of useQuery
-------------------code----------------------
 return useInfiniteQuery<Post[], Error>({
    queryKey: ["posts", query],
    queryFn: fetchPosts,
    staleTime: 1 * 60 * 1000, // 1m
    keepPreviousData: true,
  });
-------------------code----------------------

when we use useInfiniteQuery we can`t use page hook to track the page number 
cause useInfiniteQuery handle the pagination automaticly and using page hook 
with useInfiniteQuery may lead to issue with caches and data constantly

- so we will remove page from our interface and usePosts hook and the page use state 

so how we will calculate the page number for that we will use getNextPageParam
getNextPageParam is take two parameter the first one is lastPage and the second is allPages
allPages it contains multi array each array has group of posts 
so to move from page one to page two we take the length of allPages and add 1 to it 
-------------------code----------------------
return useInfiniteQuery<Post[], Error>({
    queryKey: ["posts", query],
    queryFn: fetchPosts,
    staleTime: 1 * 60 * 1000, // 1m
    keepPreviousData: true,
    getNextPageParam: (lastPage, allPages) => {
      // 1 - 2
      return allPages.length + 1;
    },
  });
-------------------code----------------------

now we don`t want to incrument the allPages forever, we want to to incrument the pages 
until the last page 
for jsonplaceholder the lastpage is empty array so we can write expertion like that 
we do that hard experition cause jsonplaceholder doesn`t povide us with number of pages
-------------------code----------------------
getNextPageParam: (lastPage, allPages) => {
  // 1 - 2
  return lastPage.length > 0 ? allPages.length + 1 : undefined;
},
-------------------code----------------------

- now when the user press on the loadbutton ReactQuery call the getNextPageParam to get the 
next page number then it will pass the page number for the query function 

as best practice we should pass pageParam to 1 to start from the first page 
-------------------code----------------------
const fetchPosts = ({ pageParam = 1 }) =>
    axios
      .get("https://jsonplaceholder.typicode.com/posts", {
        params: {
          userId: query.userId,
          _start: (pageParam - 1) * query.pageSize,
          _limit: query.pageSize,
        },
      })
      .then((res) => res.data);
-------------------code----------------------

- now in PostList we have multi errors 
first we remove the Previous button 
and for the next button we replace Next with Load 
and instead of incrument the page manually 
-------------------code----------------------
() => setPage(page + 1)
-------------------code----------------------

we call fetchNextPage 

- first we call the property from the usePost
-------------------code----------------------
const {
    data: posts,
    error,
    isLoading,
    fetchNextPage,
  } = usePosts({ userId, pageSize });
-------------------code----------------------

- then 
-------------------code----------------------
<button
  className="btn btn-primary my-3 ms-1"
  onClick={() => fetchNextPage()}
>
  Load
</button>
-------------------code----------------------

- next we should disable the button if we are fetching the next page so we call another 
property calles isFetchingNextPage
-------------------code----------------------
const {
    data: posts,
    error,
    isLoading,
    fetchNextPage,
    isFetchingNextPage,
  } = usePosts({ userId, pageSize });
-------------------code----------------------

- and add it to the button 
and we make our Loading statement more dynamicly
-------------------code----------------------
<button
  className="btn btn-primary my-3 ms-1"
  disabled={isFetchingNextPage}
  onClick={() => fetchNextPage()}
>
  {isFetchingNextPage ? "Loading" : "LoadMore"}
</button>
-------------------code----------------------

- next we have error where we map the posts 
-------------------code----------------------
{data.map((post) => (
  <li key={post.id} className="list-group-item">
    {post.title}
  </li>
))}
-------------------code----------------------

- cause posts we no longer have array of posts 
instead we have an instance of InfiniteData
-------------------code----------------------
const posts: InfiniteData<Post[]> 
-------------------code----------------------

- so we map posts.pages then we map each post the previous same 
li before PS: we used React.Fragment cause we don`t wan to add div between each element
-------------------code----------------------
<ul className="list-group">
  {posts.pages.map((page) => (
    <React.Fragment>
      {page.map((post) => (
        <li key={post.id} className="list-group-item">
          {post.title}
        </li>
      ))}
    </React.Fragment>
  ))}
</ul>
-------------------code----------------------

next we need to add key for each page cause we are using map 
and cause the page is array we used index
PS: we shoukd set the key for each map 
-------------------code----------------------
{posts.pages.map((page, index) => (
  <React.Fragment key={index}>
    {page.map((post) => (
      <li key={post.id} className="list-group-item">
        {post.title}
      </li>
    ))}
  </React.Fragment>
))}
-------------------code----------------------

*** 15-_Mutating_Data *** 
how we can muting data in the src/react-query/TodoForm.tsx we can we access 
the data using the ref command as sinple as that 
-------------------code----------------------
<div className="col">
  <input ref={ref} type="text" className="form-control" />
</div>
-------------------code----------------------

- first we but TodoForm and TodoList components in App.tsx
-------------------code----------------------
<>
  <TodoForm />
  <TodoList />
</>
-------------------code----------------------

- now we open the Browser and we can see that there is no submission functionality
so first in TodoForm we handle the submission

first we prevent the form from post the data to server 
-------------------code----------------------
<form
  className="row mb-3"
  onSubmit={(event) => {
    event.preventDefault();
  }}
>
-------------------code----------------------

- now we are ready to muting data to do that we should mutation hook in ReactQuery
we use useMutation hook it takes mutationFn (Ps useQuery take queryFn)
-------------------code----------------------
useMutation({
    mutationFn: (todo: Todo)
  })
-------------------code----------------------

- now we need to import the Todo interface 
so we export from the useTodos.ts 
-------------------code----------------------
export interface Todo {
  id: number;
  title: string;
  userId: number;
  completed: boolean;
}
-------------------code----------------------

- in useMutation we call axios and pass the endpoint as first argument and the todo argument mutationFn
as second argument to axios
and we pass then as useQuery
now we call useMutation and got object we called addTodo
-------------------code----------------------
const addTodo = useMutation({
    mutationFn: (todo: Todo) =>
      axios
        .post("https://jsonplaceholder.typicode.com/todos", todo)
        .then((res) => res.data),
  });
-------------------code----------------------

- finally where we submit the form we call the addTodo with mutate method 
the mutate method will send the data to backend using our useMutation that we defined
before 

-------------------code----------------------
addTodo.mutate({
          id: 0,
          title: ref.current.value,
          completed: false,
          userId: 1,
        });
-------------------code----------------------

- we have error complation error says 
-------------------code----------------------
'ref.current' is possibly 'null'.
-------------------code----------------------

- so we add ? (optional chaining)
-------------------code----------------------
title: ref.current?.value,
-------------------code----------------------

- we have another error in title
-------------------code----------------------
Type 'string | undefined' is not assignable to type 'string'.
  Type 'undefined' is not assignable to type 'string'.
-------------------code----------------------

the reason of that if 
ref.current? is null, the full experition result ref.current?.value will be undefined

to fix that 
-------------------code----------------------
if (ref.current && ref.current.value)
addTodo.mutate({
  id: 0,
  title: ref.current?.value,
  completed: false,
  userId: 1,
});
-------------------code----------------------

- now we test our implomantaion
first we open the Network tap in dev tool and press add when the form is empty
we can see there is no post request

now we try write "test" in the form and press Add button we can see in the Network tap (preview)
that we successfully send the data to the server 
-------------------code----------------------
{id: 201, title: "test", completed: false, userId: 1}
-------------------code----------------------

the id 201 is generated by the server 

- now next step to add the value to our list 
un useMutation we have "onSuccess" when the post request goes well and 
"onError" when error happend and "onSettled" wherever the post request successful or not 

we will handle onSuccess so it takes 3 arguments first is the data in ReactQuery the
object we get from the backend we can called savedTodo
variables is the input data 
-------------------code----------------------
onSuccess?: ((data: any, variables: Todo, context: unknown)
-------------------code----------------------

now if we write savedTodo we can`t see the type to fix that we add generic type argument
to the post request
-------------------code----------------------
 mutationFn: (todo: Todo) =>
    axios
      .post<Todo>("https://jsonplaceholder.typicode.com/todos", todo)
      .then((res) => res.data),
    onSuccess: (savedTodo)
-------------------code----------------------


now we can see the type 
-------------------code----------------------
onSuccess(data: Todo, variables: Todo, context: unknown):
-------------------code----------------------

now the second argument we called newTodo (the input data)
and we log the result to make sure that everything works fine
-------------------code----------------------
mutationFn: (todo: Todo) =>
      axios
        .post<Todo>("https://jsonplaceholder.typicode.com/todos", todo)
        .then((res) => res.data),
    onSuccess: (savedTodo, newTodo) => {
      console.log(savedTodo);
    },
-------------------code----------------------

now if we check the console tab we can see the saved data 
-------------------code----------------------
{id: 0, title: 'dsadsad', completed: false, userId: 1}
-------------------code----------------------

- now we have two approchs to update the list 
1- invalidating the cashe: so we can tell ReactQuery that what we have in the cashe
in invalid so ReactQuery will refetch the data from the backend
(but that not working with jsonplaceholder case what we send it to the server is fake)

but to do that we need to access the QueryClient that exsit main.tsx inside the TodoForm 
to do that we use another hook called useQueryClient 
-------------------code----------------------
const queryClient = useQueryClient();
  const addTodo = useMutation({
    mutationFn: (todo: Todo) =>
      axios
        .post<Todo>("https://jsonplaceholder.typicode.com/todos", todo)
        .then((res) => res.data),
    onSuccess: (savedTodo, newTodo) => {
      queryClient.invalidateQueries({
        queryKey: ["todos"],
      });
    },
  });
-------------------code----------------------

this will invalid all the queries that start with todos


2-  update the data in the cashe directly 
queryClient.setQueryData
we pass the first argument todos which is queryKey, and as second argument 
we pass updater function 

we can see the type of updater is unknown so we need to pass generic type 
to let React know the type of data 
-------------------code----------------------
QueryClient.setQueryData<unknown>(queryKey: QueryKey, updater: unknown
-------------------code----------------------

now the update is function so we update the data like we update the data normally
usng ...
-------------------code----------------------
const addTodo = useMutation({
    mutationFn: (todo: Todo) =>
      axios
        .post<Todo>("https://jsonplaceholder.typicode.com/todos", todo)
        .then((res) => res.data),
    onSuccess: (savedTodo, newTodo) => {
      // first way
      // queryClient.invalidateQueries({
      //   queryKey: ["todos"],
      // });

      // second way
      queryClient.setQueryData<Todo[]>(["todos"], (todos) => [
        savedTodo,
        ...todos,
      ]);
    },
  });
-------------------code----------------------

we complation error 
-------------------code----------------------
Type 'Todo[] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator
-------------------code----------------------

coz todos could be empty so we fix it 
-------------------code----------------------
queryClient.setQueryData<Todo[]>(["todos"], (todos) => [
  savedTodo,
  ...(todos || []),
]);
-------------------code----------------------

- now we test our code 
