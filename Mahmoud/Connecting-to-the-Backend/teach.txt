*** 2-_Understanding_the_Effect_Hook ***
Reminder:
- React component should be a Pure
A pure function is one that always returns the same result given the same input. Pure
functions should not modify objects outside of the function.

- so to keep components pure
we should keep changes out of the render phase

So, the idea is that to keep components pure,
we should avoid making changes to the data or behavior of the component during the render phase.
Instead, we should handle those changes in a different part of the component's job,
like before or after the render phase.
This helps in maintaining a clear and organized structure in the code.

            (component)
props ---->    Pure    -----> JSX

but somtimes we need
*Store data in local storage
*call the server to fetch/save data
*Manually modify the DOM elements

so where can we employ that?
            (component)
props ---->    Pure    -----> JSX
                ?

here we use the Effect hook
useEffect()

with useEffect hook we can tell React to excute a piece of code after a component is rendered
ex:
inside the Lesson1.tsx we add 
inside div
input.form-control

and let say when the app start we want to put focus on this input field
to do this:
- use the Effect hook to take reference to this input field
- first we create useRef and assign it to null
const ref = useRef<HTMLInputElement>(null);
- then we assign ref object to input field 
<input ref={ref} type="text" className="form-control" />
- in this code has nothing to do with return statement so we are changing the state of the DOM 
  so we say this piece of code has a Side Effect (it change somthing outside this component)
  and now our component is not Pure
if (ref.current) ref.current.focus();
- now to change it to Pure component we use the Effect hook
to use Effect hook we create an arrow function and move the code which
coz the outside effect to inside it
useEffect(() => {
    if (ref.current) ref.current.focus();
  });

PS: 
- like State and Ref Hooks we can only call the Effect hook in the Top Level in our component
in other word we can`t call it inside if statements or Loops

- we can call the same Effect Hook to serve multi perposes (we can write multi use Effect in the same component)
useEffect(() => {
    document.title = "My App";
  });

- we have multi Effect hooks in our component React run them in order after each render.
now backing to our application we can see that our input field is focused and our app title is called My App



*** 3-_Effect_Dependencies ***
Recap:
the function that we pass to useEffect hook it excuted after each rendered

but thier are a situations when we don`t want the that default behavior of Effect hook
and have more control about when Effect hook should be excuted


ex:
ProductList component

- in this component we declear state hook to store our product
const [product, setProduct] = useState([]);

- we use useEffect to fetch the data from the server (fetch the product from the server)
we refer to the function which we pass inside the Effect hook as callback function (coz React will call this function back)
to make it simple we will log ("Fetching product")

useEffect(() => {
    console.log("Fetching products");
  });

- then set the products to new product
useEffect(() => {
    console.log("Fetching product");
    setProduct(["Clothing", "Household"]);
  }); 

- now we have a compliation error says:
/Type 'string' is not assignable to type 'never'./

the reason we see this erro coz we initialized  useState content with empty array so the TS compiler dosen`t know which kind of object
we want to store inside this array (are we gonna store [strings, numbers, boolean, Date] and so...)
to fix that 
1- initialize it to "" empty string
const [product, setProduct] = useState([""]);
2- using angle brackets
const [product, setProduct] = useState<string[]>([]);

- now we call ProductList in the App.tsx
now we can see in the browser console that we had too much erros (we end up with infinite loop)
to see why we ended up with infinite loop 
- we comment to see cleary by stoping the loop
{/* <ProductList /> */} 

why we have an infinite loop
- in ProductList.tsx we can see in the function that we pass inside Effect hook (which render after each render) 
but in the funciton that we pass it to Effect hook we updating the State hook which create another render
and that means our Effect hook will excute one more time which make us end in infinite loop
useEffect(() => {
    console.log("Fetching product");
    setProduct(["Clothing", "Household"]);
  });

- to solve that problem we should tell React to run Effect hook only one time the first time that our component rendered
to do that
useEffect has another argument which is optional and we pass empty array in this second argument we can add one or more variable which can be props
If the second argument present (React.DependencyList), effect will only activate if the values in the list change. so passing empty array in this second argument
is like saying "Hey React don`t activate this function again" (coz we set this function React.DependencyList to empty {effect activation to noun})


useEffect(() => {
    console.log("Fetching product");
    setProduct(["Clothing", "Household"]);
  }, []);


- now after refresh the browser we don`t see errors anymore and we have 
Fetching product
Fetching product

coz we have the strict mode in main.tsx (which is React feature to render our component two times
only happen in the developer mode (not when relase our project to production))
<React.StrictMode>
    <App />
</React.StrictMode>

- now to take this example to the next level
adding drop down list to display the categories when the user select a category 
we want to the show the product in that category

- in App.tsx
above ProductList component
we add 
select.form-select>option*3

result:
<select className="form-select">
  <option value=""></option>
  <option value="Clothing">Clothing</option>
  <option value="Household">Household</option>
</select>

- to keep track of the selected category in state variable
so when the state is changed the product list we reRender
so we create useState hook

const [category, setCategory] = useState("");

- next we need to handle the change event of this select element
onChange={(event) => setCategory(event.target.value)}

to check that the state is changed we go to devTool 
and go to "Components" then we Click the state place element (App in this case)
and we can see the all the hooks state

- now we define the shape of our data (interface)
shortcut: if our interface is simple Instead of writing 
old: Instead of define interface
interface Props {}
const ProductList = ({ category }: Props) => {}

shortcut:  we can wirte inline (but only if the interface is simple)
const ProductList = ({ category }: { category: string })

- now in ProductList
we modify to
console.log("Fetching product in", category);

- now back to App.tsx we pass the category 
<ProductList category={category} />

- we got in our console
Fetching product in 
coz nothing is selected but if changed the droplist we still don`t see anything 
coz the empty array that we pass it as secoud argument to useEffect
to solve the bug in our code 
useEffect(() => {
    console.log("Fetching product in", category);
    setProduct(["Clothing", "Household"]);
  }, [category]);
*******************************************************************
to Recap:
the second argument of the Effect hook cases:
1- without second argument
useEffect(() => {
    console.log("Fetching product in", category);
    setProduct(["Clothing", "Household"]);
  });

=> React will excute our funciton after each render

2- with empty second argument
useEffect(() => {
    console.log("Fetching product in", category);
    setProduct(["Clothing", "Household"]);
  }, []);

=> React will excute our funciton only ones the first time our component rendered

3- with second argument [oneValue, multiValues] (can be props or state variables)
useEffect(() => {
    console.log("Fetching product in", category);
    setProduct(["Clothing", "Household"]);
  }, [category]);

=> React will excute our funciton every time that value is changed
**************************************************************************

*** 4-_Effect_Clean_Up ***
somtimes the code that we pass to the effect hook doesn`t need any cleanup
for ex:
useEffect(() => {
    document.title = "My App";
  });

we only set the title of the document

But what if this is was a chat component and here we are connecting to to chat server
at some point we need to disconnect from chat server 
ex: if user navigate away from the chat page we have to disconnect from the chat server

How we can do this:
in 4-_Effect_Clean_Up/EffectClean.tsx

first we create connect constent to simulate connecting to chat server
and another constent for disconnecting

const connect = () => console.log("Connecting");
const disconnect = () => console.log("Disconnecting");

then we call it inside the an EffectHook 
useEffect(() => {
    connect();
  });

now to provide a cleaning code 
useEffect(() => {
    connect();
    return () => disconnect();
  });

so the function that we pass to the EffectHook can optionaly return disconnect() to cleanning up
cleaning up is not always necessary but if want to make a clean up this the way to do it
Generally:
the clean up function (disconnect) should stop what our Effect is doing (connect())
another example:
1 - if our EffectHook is (subscribing) somthing the cleanup function should do (unsubscribing()) 
2 - if our  EffectHook is (hiding module)  the cleanup function should do (show module) 
3- if our  EffectHook is (fetching data)  the cleanup function should do (abort fetching / ignore the result)

now let`s see how that works
in browser Dev-tool console we see three messages:
Connecting
Disconnecting
Connecting

what is happening:
in developer mode with strict mode turn on React render each component twice
the first time App component render the EffectClean component
connecting shows on console
but before React render our component the second time first it is going to remove the component from screen (the first render)
that called unmounting

like mounting paper in wall React mounting our component to screen and unmounting it when is no longer needed
so 
with strict mode enabled before React mount our component for second time React should unmounted first (the first render)
that way
Connecting => React mount the first component
Disconnecting => React unmount the first component
Connecting => React mount the second component

Mounting occurs when a component is first added to the page,
while rendering occurs when a component's state changes

*** 5-_Fetching_Data ***
let`s see how can we fetch data from the server
we will use a fake backend called json place holder
https://jsonplaceholder.typicode.com/

in this website we have multi endpoints for getting dummy data
posts / commnet / albums and so on ....
ex:
/posts	100 posts
/comments	500 comments
/albums	100 albums
/photos	5000 photos
/todos	200 todos
/users	10 users

if click to user in this address we get a bunch of users where each user object
has property like id, name and so on ..
https://jsonplaceholder.typicode.com/users

Sending HTTP REQUEST:
now to send a request to the server
we can use
1- fetch()
2- axios (library)

we will use axois 
npm i axios@1.3.4

now to fetch user data from json place holder
- import axios
import axios from "axios";

- declear stateHook to storing our users
const [user, setUser] = useState([]);

- call the server by using EffectHook
useEffect(() => {
    axios.get("https://jsonplaceholder.typicode.com/users");
  });

- because calling the server is not happening immediately (it waill take seconds or more)
axios method return a promise 
Promise: an object that holds the eventual result of failure of an asynchronous(long running ) operation

all Promises has a method called then so we gonna used to print the response (res is shortcut for resoponse)
useEffect(() => {
    axios
      .get("https://jsonplaceholder.typicode.com/users")
      .then((res) => console.log(res));
  });

now if log the res.data 
useEffect(() => {
    axios
      .get("https://jsonplaceholder.typicode.com/users")
      .then((res) => console.log(res.data));
  });
we can see the data of user objects

now if we want to print the user first name we don`t see auto compliation
and without auto compliation we maybe could access invalid properties (and make bugs in our code ) 
.then((res) => console.log(res.data[0].)); 

to fix that we use TypeScript feature (interface) to define the shape of our user object
form the console in dev tool we can see the user data shape

PS: we can only write which data we are intersted in (the data we want to use )
interface User {
  id: number;
  name: string;
  username: string;
  email: string;
  // and so
}

now we can write the shape of data that we want to fetch 
axios.get<User[]>("endpoint")

now we can show only the name 
.then((res1) => console.log(res1.data[0].name));

now to store the data 
instead of using (res1) => console.log(res1.data[0].name)
we use setUsers of state hook 
.then((res) => setUsers(res.data));
but we have compliation error coz 
const [users, setUsers] = useState([]);
we initialized users constent to empty array so the TS compiler doesn't know what kind of object 
we are going to store 
to fix that we set the type of state hook to user
const [users, setUsers] = useState([]);

finally (very importent )
add empty [] as second argument of useEffect other wise we will endup 
sendeing infinite number of request to the web causing crach the websiteuseEffect(() => {
    axios
      .get<User[]>("https://jsonplaceholder.typicode.com/users")
      .then((res) => setUsers(res.data));
  }, []);

last step
we are going to render names using map method 
<ul>
  {users.map((user) => (
    <li key={user.id}>{user.name}</li>
  ))}
</ul>

*** 6-_Understanding_HTTP_Requests ***
from the previous lesson we learn how to fetch the data
(take the code from the previous lesson)

as frontend developer is very importent to understand what is happening
under the hood when calling the get method

when we call get method axios send a HTTP Request to the server
HTTP: (Hypertxt Transfer Protocol)
a protocol to transfering data over the internet 

when we visit a website
1- Browser send a HTTP Request asking for some contant
2- Then the Server response with a HTTP Response with HTML/CSS/JS than needed 
to display website in our Browser

          Request
         ----->
Browser          Server
         <-----       
         Response

let`s see HTTP Request in Action
in dev tool we go to the network tab we see too much requests
now we will the that request which we send it by axios

we filter by [Fetch/XHR]  XHR: (XMl Http Request)
we will find two request of user (coz React Strict mode)

now in user request we can see the status and size and time (how much take in our machine)
and if we click in  user request we can see more details 

- in Headrs tap
we can see the header
what is HEADER:
every HTTP Request/Response have a two section
1- HEADER: where we specify metadata (author, date created, date modified, and file size)
2- BODY: where we get the data 

- in Preview tap
we can see the data that return from the server in formated way

- in Response tap
we can see the body of the resoponse of the server in plain text

*** 7-_Handling_Errors ***
we take the code from Understanding_HTTP_Requests
we calling the server many things can go wrong (Network goes down, Server goes offline and so on ...)
as a good developer we should anticipate(予想) error problems and handle errors properly
in JS all promises has method called catch we can use for catching errors 

now after the then method we call catch method  and give it a function 
and that function will work if somthing goes wrong while fetching the data
.catch((err) => console.log(err))
to simulate an error we change the endpoint url by adding x before users

back the browser console we got an AxiosError object
in AxiosError object we can see 
we have multi properties (code, config, messages , name, request, response and so on ...)

now to take the application to the next level 
instead of showing  error only inside the console we want to render it on screen
first:
we create stateHook 
const [error, setError] = useState("");

now instead of loging the error in console we use setError 
.catch((err) => setError(err.message));

in inside return statement
p.text-danger

<p className="text-danger">{error}</p>

we want to render error dynamically if there only error 
{error && <p className="text-danger">{error}</p>}


*** 8-_Working_with_Async_and_Await ***
some people does`t like to use .then .catch approch when working with promises

we can write the code (code from _Handling_Errors) in more linear way (direct way)

get method return promise and if this promise is resolved it return response object (result)
but what if the promise is rejected we get an error
get -> promise -> result / error

- now we will this code without then and catch methods
{
axios
      .get<User[]>("https://jsonplaceholder.typicode.com/xusers")
      .then((res) => setUsers(res.data))
      .catch((err) => setError(err.message));
  }, []);

in JS we have a method called await 
if we put before the promise we will get the result 
get -> promise -> result / error

          ↓
get -> await promise -> result / error

useEffect(() => {
    const res = await axios.get<User[]>(
      "https://jsonplaceholder.typicode.com/xusers"
    ); ....})

we got error:
'await' expressions are only allowed within async functions and at the top levels of modules.

- to resolve that we have to mark useEffect function with async()

useEffect(async () => {
    const res = await axios.get<User[]>(
      "https://jsonplaceholder.typicode.com/xusers"
    )........});

now we have another error:
Argument of type '() => Promise<void>' is not assignable to parameter of type 'EffectCallback'.

coz React dosen`t allow us to pass async function to the Effect hook 
to resolve that 
we define async inside the useEffect in function called ex: fetchUser
const fetchUser = async () => {
      
    }
- then move the const res to inside it 
const fetchUser = async () => {
      const res = await axios.get<User[]>(
        "https://jsonplaceholder.typicode.com/xusers"
      );
    };

- now we can add setUsers(res.data);

const fetchUser = async () => {
      const res = await axios.get<User[]>(
        "https://jsonplaceholder.typicode.com/xusers"
      );
      setUsers(res.data);
    };

- then right after we called 
const fetchUser = async () => {
      const res = await axios.get<User[]>(
        "https://jsonplaceholder.typicode.com/xusers"
      );
      setUsers(res.data);
    };
fetchUser();

- but what if the promise is rejected we have to wrap res with try and catch  
const res = await axios.get<User[]>(
        "https://jsonplaceholder.typicode.com/xusers"
      );

- wrap it
const fetchUser = async () => {
      try {
        const res = await axios.get<User[]>(
          "https://jsonplaceholder.typicode.com/xusers"
        );
        setUsers(res.data);
      } catch (err) {
        setError(err.message);
      }
    };

- but in setError(err.message);
we got error 
'err' is of type 'unknown'.

in TS we can`t do like 
catch (err: AxiosError) {
        setError(err.message);
      }
coz type annotation is not allowed in catch statement 

- to go around this 
error catch (err) {
    setError((err as AxiosError).message);
}

as keyword: to tell the TS compiler the type of this object

this approch is not recommanded with useEffect coz 
- we create extra function 
- wrap our code with try and catch 
- use as keyword

*** 9-_Cancelling_a_Fetch_Request ***
what if the user navigate away form the page while the user data is fetching we don`t want to stop 
fetching the data

so as best practice 
when we fetching in the Effect we should provide a function for cancel the fetch request in case the data 
is no longer needed 

To do that
- we create costant of instance of AportContoller()
const controller = new AbortController();

AbortController is class in modern browsers allows us to cancel the any operation may take a long time (fetch data, manipulate the DOM )

- now we when we call axios get method we pass as signal as secound argument 
axios
  .get<User[]>("https://jsonplaceholder.typicode.com/xusers", {
    signal: controller.signal,
})

- finally we return the clean up function 
axios
  .get<User[]>("https://jsonplaceholder.typicode.com/xusers", {
    signal: controller.signal,
  })
  .then((res) => setUsers(res.data))
  .catch((err) => setError(err.message));
return () => controller.abort();

- now to we romve the x form the endpoint url (previously we use it to simulate error)

- we have "canceled" keyword rendered always in the screen
to fix that 

- in the Network map we can see that we multi Requests the first one is canceled coz (strict mode)
it the same as user was in this page(component) and then went away 
 

*** 10-_Showing_a_Loading_Indicator ***
show Loading Indicator while fetching the data

PS: first we take the same code as 9 Component

- first we create Loading steate hook and initialized to false

- now before calling the server we setLoading to true
axios.get

- but we can`t setLoading after the calling the server
axios.get

- coz calling the server is asynchronous(long running ) operation
and asynchronous operation is non Blocking which means the calling server (code block)
is not going to stop the excution of the code the compiler will continue reading the code 
and will not wait until calling server to read the next line of code (show Loading is false)

- what we want is after calling the server to set the Loading to false
to do that we have two ways:
1- we can do that in our callbaks so fist when fetching is successful
.then((res) => {
        setUsers(res.data);
        setLoading(false);
      })

and when fetching not successful (error )
.catch((err) => {
        if (err instanceof CanceledError) return;
        setError(err.message);
        setLoading(false);
      });
PS: the order of this lines it does`t matter 
coz React will apply all the updates the it will render the component (Effect Hook)
this way is a little ugly coz we duplicated (setLoading(false))

better way
2- All promises has method called finally (we pass callback) 
and finaly method will excuted when our promise is settled (where ever is resolved or not)
with this way we can set isLoading only ones

PS: finally method does`t work the React.StrictMode on so for,
so on time being we should use the first way

- now we show the Loader in our markup 
after this line {error && <p className="text-danger">{error}</p>}
we will add .spinner-border
now we wanna render it only if isLoading true

- to check our code in the Network tap  (set the network to 3G mode and refresh the page)

*** 11-_Deleting_Data ***
take the code from 10component


- first we create delete button next to each user
button.btn.btn-outline-danger

<li key={user.id}>
   {user.name} <button className="btn btn-outline-danger">Delete</button>
</li>

- when we save the code we got extra {user.name}{" "}
{users.map((user) => (
    <li key={user.id}>
      {user.name}{" "}
      <button className="btn btn-outline-danger">Delete</button>
    </li>
  ))}
is necessary to but space between the user and the button coz when JSX/TSX compiled 
React remove all the spaces between the JSX elements

- to fix our markup looks (to make it list group)
- first step
<ul className="list-group">
and for each li 
<li key={user.id} className="list-group-item">

- next step
align the buttons to the left

we change every li to flex container by add d-flex and justify-content-between
<li key={user.id} className="list-group-item d-flex justify-content-between"

- now we don`t need the extra {" "} so we remove it (coz we depend in the css to align our buttons)

- now let`s employment delete functionality

-- in the button section we add (the function we want to create)
<button
   className="btn btn-outline-danger"
   onClick={() => deleteUser(user)}
>
-- create the deleteUser function
**************************************************
**************************************************
to delete data from the server we have two approchs:
1- Optimoitic Update (very fast) (when we assume that connecting to server well go will)
- update the UI first
- call the server to save the changes

2- Pessimisitc Update (a little slow) (when we assume that connecting to server maybe is gonna fails)
- call the server first 
- update the UI (if the call is successful)

PS:
- when possible is better to use Optimoitic Update
**************************************************
**************************************************

- now in our delte user we will use the Optimoitic Update
- update the UI
const deleteUser = (user: User) => {
    setUsers(users.filter((u) => u.id !== user.id));
  };

- now we update the Server
axios
      .delete("https://jsonplaceholder.typicode.com/users" + user.id)
now i return a proimse but we don`t want to do anything if the promise done (coz only delete data)
so we don`t call then method instead we call immediately catch method to only check if erros happned

now if errors happned we need to restore the UI to the originl state (all users)
so in the top of the method we declear method called originlUsers
const originalUsers = [...users];

now if we catch an error 
we set the user to the originlUsers
.catch((err) => {
    setError(err.message);
    setUsers(originalUsers);
});

to test our code 
- when we delete user we see request sends to the server to remove that user 
- to test when there error 
we simulate error by changing the endpoint URL 

*** 12-_Creating_Data ***
 continue on the same code from 11component

- to create data we will add button above our list ul
button.btn.btn-primary.mb-3

- we will not create submit form (coz it takes time)
we will focus on adding user to server only

- next we add to the button function called addUser when onClick

<button className="btn btn-primary mb-3" onClick={addUser}>
  Add
</button>

- we create now the addUser function
and we will use Optimoitic Update approch

- inisde the function we create newUser
const newUser: User = {
      id: 0,
      name: "Lili",
      username: "",
      email: "lili123@gmial.com",
    };
id: 0 means that the user is not save it yet

here we create User using constant but in real world Application we use the User from the from submit(ex: Expense Tracker)

- after that we need to call the server to save the changes
axios.post("https://jsonplaceholder.typicode.com/users");

- but we need to include our new user information in the request so as second argument we add our newUser
axios.post("https://jsonplaceholder.typicode.com/users", newUser);

- now we have promise
if the call to the server successful (adding .then) we should refresh our list with the same user coz 
our user will have id generated by the server after it generated we take the user list form respons body
.then((res) => setUsers([res.data, ...users]));

- now from the Dev tool we check the request status at this point in the Preview tap
we can see our new Id on the newUser (id generated by server)

********************************
- the jsonplaceholder server build like fake backend so if we send the same request
multitimes every time we got user with id of 11 but in real world App the id +1 every time we add user

- coz that if we pass multi Users in the same request we will have two user with same id 
and we will got error in the console coz when we map our user we should have unique key so that`s coz
it`s fake backend so be aware of it   
<li
  key={user.id}
***********************************

- to write our code in another way to make it more readble 

.then((res) => setUsers([res.data, ...users]))
==>
instead of calling the res we add {} and call data only 
.then(({ data }) => setUsers([data, ...users]))
and that data but to make it more readble we add alias instead
.then(({ data: savedUser }) => setUsers([savedUser, ...users]))

- finally we write handle the error if creating user if faild (using .catch)
so first we define 
const originalUsers = [...users];
then we called it when if the server didn`t allow us to create a user 
.catch((err) => {
  setError(err.message);
  setUsers(originalUsers);
});


*** 13-_Updating_Data ***
take the code form the previous (12)component 
 
- to update the data we will button next to delete button 
button.btn.btn-outline-secondary

- the aligin is a littler messedup coz we use "justify-content-between"
coz we have 3 columns and user name length is different we got this bad align

- to fix that we should grap out two buttons(delete, update)in container (div) with that we 
will only have one two columns inside the li so the name pushed to the left
and the buttons pushed to the right 

so we add div as container and move the buttons inside it 

- now our buttons is so close to fix we add margin horizontal to our buttons mx-1(bootstrap)

- now we add to the update button onClick with method called updateUser we pass it as arrow funciton
coz (inside map and we want to update only one user)
<button
  className="btn btn-outline-secondary mx-1"
  onClick={() => updateUser(user)}
>

- create the updateUser function
- instead of using form (take time and want to focus only the update functionality) we update an user by adding ! to it 
const updateUser = (user: User) => {
    const updatedUser = { ...user, name: user.name + "!" };
  };
next we call setUser() with map method coz we want to update
if the current user id is equal to the id of the user we want to update return the updated user other wise return the same user
setUsers(users.map((u) => (u.id === user.id ? updatedUser : u)));

- now we test our code until this point

- after testing now we will send our changes to the server using PUT HTTP method 
we can use put or patch method
in HTTP we use put for replacing an object while patch is using to update the object properties
which method should use depend on specification or the server coz some servers doesn`t support the patch method 

- coz we update one property we will use patch method and add the url of the endpoint + the user id and same as creating user
we pass the updatedUser user as second argument
.patch(
        "https://jsonplaceholder.typicode.com/users/" + user.id,
        updatedUser
      )

- if the server successful there is nothing to do so (we don`t have to use then)
- but if got an error we use the same way when we created a user 
.catch((err) => {
  setError(err.message);
  setUsers(originalUsers);
});

*** 14-_Extracting_a_Reusable_API_Client ***
take the code form the previous (13)component 

until this point our code is grown a little bit and we to improve it step by step
we will fix it little by little during the next lessons 

- the first issue is the deplication of our endpoint url we have repeated this 
url in two many places
to improve our code we are going to create a separate module where we can store our default settings
for making http calles 

- now in our src folder we add new folder we called services
in this folder we are going to add basic modules that provides services for functionality for our application
so the services folder is now about the UI it`s about functionality

- inside the services folder we create a file called api-client.ts
in this file we are going to create a new access client with custom configuration 

- so first we import axios
then we call axios.create and give it a configuration object
in this object we set the baseURL to the url of our backend so we go back to our component
and grap the url of the endpoint url except the user coz we want our client-api to be reuseble 
perhaps in another component we need to have a another endpoint (user, post etc ...)

axios.create({
  baseURL: "https://jsonplaceholder.typicode.com",
})

- next baseURL we can optionaly set the header if it required coz some endpoints
need to set the header in our backend we don`t need so i will comment it

- finally we export it as default

- now back to our component in the top we first we remove axios 
import axios, { CanceledError } from "axios"; 

- now we have CanceledError imported from axios and need to remove it 
import { CanceledError } from "axios";

to do that we remove it from our component (ExtractingAReusableApiClient.tsx) and instead inside the api-client.ts
we import it inisde it 
import axios, { CanceledError } from "axios";

finally in the api-clinet.ts we export it as object
export { CanceledError };

- now we can remove this from the component
import { CanceledError } from "axios";

- and instead we add 
import apiClient, { CanceledError } from "../../services/api-client";

- now we change the reference axios to apiClient

- now with this implementation our code is improved and we call apiClient everytime we want 
to call the HTTP request


*** 15-_Extracting_the_User_Service ***
- we take the same code in our last component 14
- the next issue in our component a little bit concern with making HTTP Request
for ex:
we used AbortController()
and get post put methods etc ...
and for the endpoint 

it`s look like (real world example) in resturant we have a chef not only response for cooking
but also for shopping 
but normally we want that chef to focus on it`s only own responsibility (only Cooking)

the same thing is in our component it should only handle it`s primary responsibility which
is returning some markup and handling user interactions at high level 

*********************
When we say that a React component should handle user interactions at a high level, it means that the component should be primarily responsible
for managing the state, responding to user inputs, and coordinating with other parts of the application. 
The component should encapsulate its internal logic and expose a clean interface for the rest of the application to interact with.

On the other hand, low-level details such as DOM manipulation or complex calculations may be delegated to other parts of the application or to child components. 
This helps in creating more modular and maintainable code, as each component can focus on a specific responsibility.
*********************

- so to imporve our code we should extract all our logic around making HTTP Request into a separate services 
this allow to make our code more modular and reuseble 

- inside the services folder we create "user-service.ts"


*********************
PS:
we used can Kebab case naming rule to name the ts file but we can also use camel notation(where ever you like)

{Kebab case} examples:
kebab-case
descriptive-variable-name
INTERESTING-TEXT-FILE
naming-conventions-webpage

{camel case} examples:
camelCase
youTube
powerPoint

{pascal case} examples:
PascalCase
UserService
*********************

- inside the user service first we import api client at the top
import apiClient from "./api-client";

- the we craete class and inside this class we going to create user, update user and so 
then export instance of this class as default

- now inside the UserService class we we add methods
getAllUsers()
here we grap controller constant from our component
const controller = new AbortController();

then we copy the place where we send get method 
apiClient
      .get<User[]>("/users", {
        signal: controller.signal,
      })
      
- we got error that User is not defined and coz we will write all the User get/post/put methods in 
user-service.ts it`s better to move the User interface to user-service.ts

now coz we need to use User interface also in component we need to export it from the module
export interface User {
  id: number;
  name: string;
  username: string;
  email: string;
}

- now we import the User interface inside the component and also the userService
import userService, { User } from "../../services/user-service";

- by returnig apiClient form getAllUsers method 
instead of calling apiClient in our component  we are going to call userService instead
useEffect(() => {
    setLoading(true);
    userService....})

- now simply we can use getAllUsers instead of
apiClient
      .get<User[]>("/users", {
        signal: controller.signal,
      })
we change it to 
userService
      .getAllUsers()

- now we have issue 
return () => controller.abort();
we can`t access controller in the component and in the same time we don`t want to export it from user-service module 
(we don`t export the detals like TV`s remote control only have a button for simple user actions {like power on ,volume up, and so ...} )

to fix that in user-servive.ts 
instead of returing apiClient
return apiClient.get<User[]>("/users", {
      signal: controller.signal,
    });
we store api client in constant
const request = apiClient.get<User[]>("/users", {
      signal: controller.signal,
    });
  return { request, cancel: () => controller.abort() }; 

now in the component file
we set 
userService
      .getAllUsers()
      .then((res) => {
        setUsers(res.data);
        setLoading(false);
      })
      .catch((err) => {
        if (err instanceof CanceledError) return;
        setError(err.message);
        setLoading(false);
      });
return () => controller.abort();
to costant 
    const { request, cancel } = userService.getAllUsers();
    request
      .then((res) => {
        setUsers(res.data);
        setLoading(false);
      })
      .catch((err) => {
        if (err instanceof CanceledError) return;
        setError(err.message);
        setLoading(false);
      });

    return () => cancel();

exercise move all the other methods 

- next we need to work on deleting user (move it user-service.ts)
so next to getAllUsers() we create deleteUser() 
we move the code from the component
.delete("/users/" + user.id)
-- we remove user
-- then we return it (promise)
return apiClient.delete("/users/" + id);
-- finally in the component file we call the deleteUser()
userService.deleteUser(user.id).catch((err) ...)


the same technique we use with addUser and updateuser 

with this changes we have better separation concern and our code modular so we can use 
user-service anywhere we want in application
